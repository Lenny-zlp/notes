脚手架在上禁止运行时配置

https://blog.csdn.net/lihefei_coder/article/details/100522281

#  超链接技巧

```html
<base target="_blank">
	页面的所有跳转，在新窗口打开
<a href="#" target="_self">
	默认页面在当前窗口打开
```

# 锚点的使用

```html
设置锚点
<h3 id="md"></h3>
同页面的跳转
<a href="#md">链接到锚点</a>
不同页面的跳转
<a href="xxxxxxxxxxxx.html#md">链接08页面的锚点</a>
```

# 特殊字符

```html
&lt;小于号
&gt;大于号
&nbsp;空格
&yen;￥的标志
&copy;©的标志
<hr />水平线
<br />换行
```

# 图像标签img 属性

```html
<img src="来源" title="鼠标悬停时显示的内容" alt="图片不能显示时替换的文本"
```

# 表单控件

```html
<form action="1.php" name="reg" method="post">
    action收集的信息提交给那个文件处理 
```

```html
<label for="user">昵称: <input type="text" id="user"></label>
```

- label for="input id的值",当点击label里边文字的时候,input获取了光标焦点

```html
用户名: <input type="text" value="孙悟空" name="username" maxlength="6"  />
```

```html
密码: <input type="password" name="pwd" maxlength="6" />
```

```html
单选框： <input type="radio" name="gender" > 
```

```html
多选框：<input type="checkbox">
多选框：<input type="checkbox">

```

```html
下来菜单：
<select>
			    	<!-- 下拉菜单选项 -->
			   		<option>1995</option>
			   		<option selected="selected">1996</option>
			   		<option>1997</option>
</select>
```

```html
上传信息: <input type="file">
```

```html
点击注册的属性<input type="submit" value="立即注册">
```

```html
没有点击的属性<input type="button" value="普通按钮">
```

```html
图片按钮<input type="image" src="images/btn.png">
```

```html
重置按钮<input type="reset">
```

```css
<!-- 邮箱控件 必须包含@-->
		邮箱: <input type="email">
		<br><br>
		<!-- 电话号码控件 语义化-->
		电话: <input type="tel">
		<br><br>
		<!-- 搜索控件 语义化-->
		搜索: <input type="search">
		<br><br>
		<!-- 数字控件 -->
		数字: <input type="number">
		<br><br>
		<!-- 网址控件 输入的内容必须包含http://-->
		网址: <input type="url">
		<br><br>
		<!-- 时分控件 -->
		时间: <input type="time">
		<br><br>
		<!-- 日期控件 -->
		日期: <input type="date">
		<br><br>
		<!-- 周控件 -->
		周: <input type="week">
		<br><br>
		<input type="submit">
```

```css
<form action="1.php">
		<!-- placeholder 占位符 
			autofocus 自动获取光标焦点
			autocomplete  自动完成
			autocomplete="on" 默认值 输入框会记住输入的内容
						="off"  输入框不会记住输入的内容
		    required 必填项 (输入的内容不能为空)

		-->
		<input type="text" placeholder="大傻瓜" autofocus autocomplete="off" required>
		<br><br>
		<input type="submit">
	</form>
```



# 边框的线型

```css
solid  实线； dotted  点线；  dashed  曲线； double 	双线 
```

# 表格边框合并

![](D:\00笔记—来于小雨\00笔记\assets\表格1.png)

![](D:\00笔记—来于小雨\00笔记\assets\表格.png)

```css

border-collapse: collapse;
*表格边框合并, 该属性只能用在表格上

```



# 获取光标状态

```css
/*:focus  伪类  获取光标焦点的状态  通常配合input使用*/
		.username input:focus {
			background-color: red;
		}
```

# 外边距塌陷

当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和，而是两者中的较大者。这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。

对于两个嵌套关系的块元素，如果父元素没有上内边距及边框，则父元素的上外边距会与子元素的上外边距发生合并，合并到父元素上,合并后的外边距为两者中的较大者，即使父元素的上外边距为0，也会发生合并。

解决 overflow：hidden。可以为父元素添加overflow:hidden。触发了BFC, 块级格式化上下文, 独立的布局区域,不会受到外部因素的干扰

# 盒子阴影

```css
/*盒子阴影
				第1个值阴影的水平偏移量,正值向右,负值向左
				第2个值阴影的垂直偏移量,正值向下,负值向上
				第3个值阴影的模糊范围
				第4个值是阴影的大小
				第5个值是阴影的颜色
				阴影默认是外阴影
			*/
			/*box-shadow: 20px -10px 20px 2px #666;*/
			/*内阴影 inset*/
			/*box-shadow: inset 0px 0px 120px 2px red;*/
			/*多组阴影之间用逗号隔开*/
			box-shadow: 20px -10px 20px 2px #666, inset 0px 0px 120px 2px red;
```

# 盒子透明度

```css
rgba(255, 255,255, .5);
opacity: .5;
```

# 浮动的特点

```css
/*浮动的特点*/

​            /*1.浮动的元素会脱离标准流的控制,不占据原来的位置

​              2.浮动可以使(块)元素在一行上显示

​              3.浮动只能浮动到父元素的左边和右边,受到父元素内边距的控制

​              4.浮动元素顶对齐, 代码换行没有缝隙

​              5.浮动元素不会影响上边标准流里的块元素,只会影响下边的元素

​              6.浮动元素有了行内块元素的显示特点

​                ◆块元素浮动之后,不会默认父元素的宽度了,默认宽高0, 内容会撑开宽高

​                ◆行内元素浮动之后,可以设置宽高了

​            */
```

# 清除浮动的原因

-   清除浮动是为了解决父元素不能设置高度, 里边的子元素浮动之后不能撑开父元素高度的问题

# 清除浮动的方法

```css
1/*给浮动元素的父元素(亲爹),使用overflow: hidden;清除浮动, 触发了BFC	,块级格式化上下文, 独立的布局区域, 不受到外部因素的干扰
弊端, 子元素出了父元素的范围(边界),多了部分的会被隐藏掉*/
2/*给浮动元素的父元素(亲爹), 调用.clearfix:after 伪元素清除浮动*/
		.clearfix:after {
			content: '';
			display: block;
			height: 0;
			/*显示模式为隐藏*/
			visibility: hidden;
			clear: both;
		}
		/*为了兼容ie6-7清除浮动*/
		.clearfix {
			*zoom: 1;
		}
3/*给浮动元素的父元素(亲爹), 调用clearfix 双伪元素清除浮动*/
		.clearfix:before, .clearfix:after {
			content: '';
			display: table;
		}
		.clearfix:after {
			clear: both;
		}
		.clearfix {
			*zoom: 1;
		}
```

# 伪元素

```css
/*:hover 伪类 ::before 前伪元素, 
			::before 前伪元素是在元素的里边的前边插入伪元素,可以当做行内元素对待
			可写成:before
		*/
		.box:before {
			/*content 为必写属性, 否则伪元素不生效*/
			content: '前伪元素';
			display: block;
			background-color: green;
			color: #fff;
		}
		/*::after 后伪元素, 在在元素的里边的后边插入伪元素,可以当做行内元素对待
			可写成:after  
		*/
		.box:after {
			content: '后伪元素';
			background-color: red;
			color: #fff;
		}
```

# 绝对定位

```css
/*绝对定位
				1.绝对定位的元素脱标了,不占据原来的位置
				2.绝对定位的元素, 所有父元素没有定位,位置偏移基于浏览器
				3.绝对定位的元素,如果父元素有定位,位置偏移基于离他最近的使用了定位的父元素位置偏移
				4.绝对定位的元素有了行内块的显示特点
					◇绝对定位的块元素,不会默认父元素的宽了,默认宽高0, 内容会撑开宽高
					◇绝对定位的行内元素可以设置宽高了

			*/
```

# 绝对定位

```css
/*固定定位
				1.固定定位的元素脱标,不占据原来的位置
				2.固定定位的元素位置偏移基于浏览器可视窗口
				3.固定定位的元素有了行内块元素的显示
				    ◆固定定位的块元素不会默认父元素的宽度了,默认宽高为0,内容会撑开宽高
				    ◆固定定位的行内元素可以设置宽高了
			*/
```

# 定位盒子的居中显示！！！

```css
1.son {
			position: absolute;
			/*向右走父元素宽度的一半*/
			left: 50%;
			/*向左走自身宽度的一半*/
			margin-left: -50px;
			/* left: 0; */
			/*bottom: 0;*/
			/*向下走父元素高度的一半*/
			top: 50%;
			/*向上走自身高度的一半*/
			margin-top: -50px;
			width: 100px;
			height: 100px;
			background-color: #f00;
			/*margin: 0 auto; 只能使标准流里的块元素水平居中*/
			/*margin: 0 auto;*/
		}
2.son {
			/*这种方法,子元素必须设置宽高,被内容撑开的宽高无效*/
			position: absolute;
			left: 0;
			right: 0;
			top: 0;
			bottom: 0;
			margin: auto;
			width: 100px;
			height: 100px;
			background-color: #f00;
		}
3.son {
      width: 600px;
      height: 300px;
      background-color: red;
      position: absolute;
      /* 相对于父亲 宽高 */
      top: 50%;
      left: 50%;
      /* 相对于自身 宽高 */
      transform: translate(-50%, -50%);
    }
```

# 元素显示与隐藏

```css
.red {
			/*隐藏对象,隐藏之后不占位置*/
			/*display: none;*/
			/*对象隐藏, 隐藏之后还占据位置*/
			visibility: hidden;
			background-color: #f00;
		}
```

# 元素移除的处理

```css
/*visible 溢出可见
			  scroll 不管内容是否溢出都生成滚动条
			  auto 内容溢出生成滚动条,不溢出不生成滚动条
			  hidden 溢出隐藏
			*/
			overflow: hidden;
			/*溢出的内容不占位置*/
```

# 鼠标样式

```css
	/*
			  鼠标样式
			  default 默认值 小白
			  pointer 小手
			  move    移动
			  text    文本
			  not-allowed 禁止
			  help  帮助
			 */
			cursor: not-allowed ;
```

# 轮廓线清除

```css
input {
			/*清除轮廓线*/
			outline: 0;
		}
		textarea {
			/*禁止文本域拖拽*/
			resize: none;
		}
```

# 单行文本省略号实现

```css
.box {
			width: 200px;
			height: 300px;
			background-color: #ccc;
			/*文字强制一行显示*/
			white-space: nowrap;
			/*溢出隐藏*/
			overflow: hidden;
			/*溢出省略号*/
			text-overflow: ellipsis;
			/*实现单行文本省略号,white-space: nowrap;overflow: hidden;text-overflow: ellipsis; 缺一不可*/
		}
```

# 清除图片的缝隙

```css
.box img {
			/*清除图片底部的缝隙,只需要将vertical-align的值设置为除了baseline(基线以外的值)都可以, 或者将图片转换为块元素,也能清除图片底部的缝隙
			top 顶对齐
			middle 垂直居中对齐
			bottom 底对齐
			*/
			/*vertical-align: middle;*/
			/* display: block; */

		}
```

# 输入框占位符

```css
input {
			color: red;
		}
		/*占位符选择器,修改占位符的样式*/
		input::placeholder {
			color: yellow;
		}
	  <!-- 占位符, 当输入内容的时候,占位符消失, 删除输入的内容,占位符出现 -->
	<input type="text" placeholder="金装大灰狼">
```

# 背景线型渐变

```css
background-image: linear-gradient(to right, red, green, blue, yellow, orange, pink);
background: linear-gradient(to right, red, green, blue, yellow, orange, pink);


/* 起始方向，颜色1，颜色2，...*/
background: -webkit-linear-gradient(30deg, red, blue);

/* 1.必须有私有前缀*/
/* 2.起始方向：可以为方向名词left 或 deg度数，默认从上到下*/
/* 3.颜色个数：最少2两个颜色*/
```

# 伪类选择器的使用

first-child

**选择父元素的第一个子元素E。** 

last-child

**选择父元素的最后一个子元素E**。

nth-child(n)

**匹配父元素的第n个子元素E，假设该子元素不是E，则选择器无效。** 

nth-last-child(n)

**匹配父元素的倒数第n个子元素E，假设该子元素不是E，则选择器无效。** 

nth-of-type(n)

**匹配同类型中的第n个同级兄弟元素E。** 

该选择器总是能命中父元素的第n个为E的子元素，不论第n个子元素是否为E 

# flex布局（圣杯布局）

```css
display:flex;
flex-direction:row /* 默认值 从左到右 */
flex-direction:column  从上到下
```

```css
justify-content:center  在主轴居中对齐
justify-content:space-around  平分剩余空间
justify-content:space-between  先贴两边 再平分剩余空间
flex-wrap:nowrap;子元素不会换行
flex-wrap：wrap ；会换行
```

```css
子项为单行
align-items center 	  在侧轴居中
align-items stretch 	侧轴拉伸
```

```css
align-content:flex-start  默认值 侧轴头部开始排列
align-content:flex-end   侧轴尾部开始排列
align-content:center  侧轴中间显示
align-content:sapce-around 侧轴平分剩余空间
align-content:space-between  先分布两头  在平分剩余空间
align-content:streth  默认值 子项元素高度平分父元素高度
```

- align-content：需要设置换行；
- space-around和 space-between：把多行都看成单独的整体，整体之间有剩余空间平分。
- stretch：在侧轴方向上会拉伸；

# rem布局

em布局的核心：rem+媒体查询；

- rem：唯一控制；只要盒子用rem作为单位，**当 HTML字体大小发生改变，使用rem单位元素都会发生改变；**
- 媒体查询：把屏幕划分不同档位，等待变化；
- rem+媒体查询加在一起：划分屏幕，等待变化；变化谁？变化唯一控制 rem（HTML字体大小）
- 引用flexible.js  文件 

# 响应式布局

- 已经学习：单独制作移动端3，基础班PC端；
- 响应式通过一份代码，三个端显示；响应不同的终端，显示不同的布局（排版）效果；

利用bootstrap框架  栅格系统  响应式工具

# js转数据类型

- - - Number()：
      - "abc100"---->NaN;
    - parseInt()、parseFloat()：
      - 转成功，字符串前面的组成部分有数字；
      - true/null/undefined  转为NaN；
  - 结果：数字（0,1,10，NaN）
- 转字符串：相当于给你要转的这个数据左右两边加单双引号；
  - String(NaN)  :  ------>"NaN";
  - .toString()  :   null undefined 不能用；
- 转布尔值：
  - Boolean（）：结果返回布尔值；
  - 转false6种情况
    - 空字符串：“”
    - 数字：0、NaN；
    - null、undefined
    - false

# 操作符的优先级

 // 1. 第一优先级：()
  // 2. 第二优先级：++ -- !
  // 3. 第三优先级： * /  %
  // 4. 第四优先级： + -
  // 5. 第五优先级： > >= < <=
  // 6. 第六优先级： == != === !==
  //  7. 第七优先级： &&
  //   8. 第八优先级： ||
  //   9. 第九优先级： = += -= *= /= %=  

# 分支结构

- switch-case结构：主要用于多个**固定值**之间的判断，只能做固定值的判断

```
switch （数据）{
  case 固定值1: 
    // 当 数据 === 固定值1 时执行的代码; 先看类型，看值；
    
    // 表示当前 情况结束；
    break;
        
  case 固定值2: 
    // 当数据 === 固定值2时执行的代码;
    // break;
        
  case 固定值3: 
    // 当数据 === 固定值3时执行的代码;
    break;
  // 中间还可以写多个判断
  
  
  default : 
    // 当数据和上面的所有固定值都不相等的时候执行的代码
    break;
}
```

# 三元表达式

a > b ? a : b;  true 返回a的结果  作为整个表达式的结果  

​			false 返回b的结果 作为整个表达式的结果

# while循环

```
// 定义一个变量，从1开始
var num = 1;

// 定义一个总和，一开始是0，没有加任何数之前，都是0；
var sum = 0;


// 使用循环让num不断的自增
while (num <= 100){
  sum = sum + num;
  num++;
}
```

# for循环

```
// 定义一个总和
var sum = 0;
// 先求出1-10之间的偶数
for(var i =1; i <= 10; i++){
  // console.log(i);
  // 判断i是否是2的倍数
  if(i % 2 === 0){
    console.log(i + '是偶数');
    // 把偶数相加
    // sum = sum + i;
    sum += i;
  }
}
```

# break和continue

总结：这个地方只是用for做终止

- break用于结束整个循环
- continue用于结束整个循环中的一次，**结束当前这次循环**；
- break和continue**后面的代码都不会执行**，执行前面的代码；

# 作用域！！！

- 作用域：作用范围，能生效的范围；
- 为什么要学作用域？**目前，我们要分清楚自己的声明的变量在哪个作用域下，也就是生效的范围是多大；配合下面预解析的知识，经常是面试比较常问的基础题**；
- 全局：
  - 全局作用域：能在页面的任何位置都可以访问
  - 全局变量：在全局作用哉下声明的变量；
- 局部：
  - 局部作用域：只能在局部的作用域范围进行访问；
  - 局部变量：在局部作用域下声明的变量；

```js
var a = 10;
function f1(){
  console.log(a);
}
f1();// 变量a在函数外定义，可以在函数内使用




function f2(){
  var b = 20;
}
// 变量b在函数内定义，在函数外无法访问，报错： b is not defined
console.log(b); 
```

# 预解析 面试题！！！

提前、解析（分析）会把**初始化的声明的变量、函数**（不包括函数表达式），全部提升到**当前作用域**的最顶端；

```js
fn();// 正常执行
function f1(){
  console.log(1);
}
fn(); // 正常执行


f2();// 报错 ： f2 is not a function
var f2 = function(){
  console.log(2);
}
// function 关键字定义的函数，可以在定义之前使用，函数表达式的不行
```

```js
// 观察下面的代码，说出执行结果
var num = 10;
fun();
console.log(num);


function fun() {
  console.log(num);
  var num = 20;
}

// ------------------------------------------------------------变量提升的演示
// 预解析：先把你声明变量、函数先全部提升到你当前的作用域的最顶端；
var num;

function fun() {
    var num;
    console.log(num);
    num = 20;
}

// 赋值；
num = 10;
// 函数调用；
fun(); // 输出 undefined；
console.log(num);
```

```js
  var num = 10;
  fun();
  console.log(num);


  function fun() {
    console.log(num);
    num = 20;
  }


// 预解析完成：执行
 var num;
 function fun() {
    // 进入函数内部执行前，预解析：
    // 考虑num 是谁的num？局部变量？全局的变量？
    console.log(num);
    // 改变是全部的num
    num = 20;
 }



  num = 10; 
  fun();
  // 看当前作用域里有没有num
  console.log(num);
```

# 简单数据类型和复杂数据类型

简单类型

```js
var a = 10;
var b = a;
b = 20;
console.log(a,b); //输出 10，20 也就是说，a的值不会受到b的值的改变而影响
```

**简单类型数据存储在内存的栈空间中，复杂类型的数据存储在内存的堆空间中**

![](D:\00笔记—来于小雨\00笔记\assets\001.png)

![](D:\00笔记—来于小雨\00笔记\assets\002.png)

- 当另一个数据发生变化，会根据变量找到对应的**栈内存**上盒子的内容，进行修改；
- **此时，简单类型的的变量赋值给另一个变量，当另一个变量改变了，不会影响原来的变量

![](D:\00笔记—来于小雨\00笔记\assets\003.png)

复杂数据类型

```js
var obj1 = {
  name : '狗蛋'
};
var obj2 = obj1;
obj2.name = '翠花';

// 输出 两个翠花 ， 也就是说，obj1的name属性受到了obj2的name属性影响
console.log(obj1.name,obj2.name); 
```

- 复杂类型在内存的储存，赋值给其他变量，也是把格子内的内容复制了一份，**
- **格子里是地址；相当于两个对象内容存的是同一份地址；**

![](D:\00笔记—来于小雨\00笔记\assets\004.png)

当另一个变量发生变化时，**修改的是同一个堆内存地址上的数据，所以obj1和obj2修改的其实是同一个对象

![](D:\00笔记—来于小雨\00笔记\assets\005.png)

```js
// 形参与实参
 // 简单数据类型
 function f1(b) {
    b = 2;
 }
 var a = 1;
 f1(a)
 console.log(a);


  // 复制数据类型
  function f2(o) {
    o.name = '翠花';
  }
  var a = {
    name: '狗蛋'
  }
  f2(a);
  // 最终a的name属性是多少？翠花
  console.log(a.name);
```

# 获取时间戳

```js
语法：
var date = new Date( );
var date = date.getdate（ ）；获取日期
var xq= date.getday（ ）；获取星期
date.getMilliseconds( ) ；获取毫秒
获取时间戳
date.valueOf( );
date.getTime( );
1*date;
Date.now( );

```

- 获取随机唯一ID值   时间戳*随机数

# 随机数字的获取

```js
Math.random( )  取0-1随机小数
Math.floor( ) 向下取整
Math.ceil( ) 向上取整
Math.round( )  把一个浮点数进行四舍五入取整
Math.abs(x)  求一个数的绝对值 正数
Math.max(x,y...)  求多个数字中的最大值，同理 Math.min(x,y...);
```

# 数组的方法 （数组方法）

```js
arr.push()  数组后面添加元素，返回值是添加数组后的长度   改变原来数组

arr.unshift（）   数组前面添加元素，返回值是添加数组后的长度   改变原来数组

arr.pop （）数组后面删除一个元素，返回值是被删除的元素   改变原来数组

arr.shift（）数组前面删除一个元素，返回值是被删除的元素   改变原来数组

arr.splice（n，m，...） n是开始的下标，m是移除的个数，后面是加需要加的元素
返回值是移除的元素的数组，如果无移除元素 返回值{}！！！原来的数组改变

arr.slice（n，m）n代表开始截取的下标，包括，m代表：结束截取的下标，不包括 ;
返回值是截取的新的数组  不会改变原来数组
n=0, m=0  全部截取 成立新的数组 不改变原来数组

arr.slice(n);
只输入一个数字  截取的是下标n到length的所有元素
返回值是截取的元素组成的新数组   不改变原来数组
arr.sort();
	排序方法 根据数组中数组元素的字符编进行排序
    参数是一个函数，需要自定义该函数， sort()会根据函数的返回结果对数组进行排序
      let arr = [12, 5, 25, 3, 10];
   1.   function fn(a, b) {
            return a - b;
        }; //函数返回结果小于0  a排在b前面 函数返回结果大于0， a排在b后面
        //升序效果
		  arr.sort(fn);
          arr.forEach(function(item) {
           			 console.log(item); //3 5 10 12 25
             })
           console.log(arr); //[3, 5, 10, 12, 25]

	2.     function fun(a, b) {
            return b - a;
        } //降序效果
       arr.sort(fun);
        console.log(arr);//[25,12,10,5,3]

    3.  也可以直接写
     arr.sort(function(a, b) {
            return a - b;
        });
        console.log(arr);//[3, 5, 10, 12, 25]
        
	4 . 还可以对数组中的字符串按照字符串的方法进行升序排序
        let arr=["a","asasd","asdf","asd","as"]
        arr.sort(function(a,b) {
            return a.length-b.length;   
        });
        console.log(arr)//["a","as","asd","asdf","asasd"]
	5.、对字符串数组执行不区分大小写的字母表排序。

        var arr = ['abc', 'Def', 'BoC', 'FED'];
        console.log(arr.sort()); // ["BoC", "Def", "FED", "abc"]
        arr.sort(function(s, t){
         var a = s.toLowerCase();
         var b = t.toLowerCase();
         if (a < b) return -1;
         if (a > b) return 1;
         return 0;
        });
			console.log(arr）// ["abc", "BoC", "Def", "FED"]
6.   对包含对象的数组排序，要求根据对象中的年龄进行由大到小的顺序排列

        let arr = [{
            name: "aa",
            age: 24,
            score: 97
        }, {
            name: "bb",
            age: 18,
            score: 50
        }, {
            name: "cc",
            age: 40,
            score: 30
        }]
        arr.sort(function(a, b) {
            return a.age - b.age;
        })
        console.log(arr);//[ 从小到大排按年龄]



var res = arr.indexOf(元素);！！!
元素存在  返回下标
元素不存在  返回-1
arr.findIndex！！!
var res = arr.findIndex(function(item) {
    return item > 50;
  });
 把满足条件的第一个元素的的下标返回，如找不到，返回-1；
```

```js
数组的复制

1，var new_arr = arr.concat( );；
2，var new_arr = arr.slice( );
3，var new_arr =  [  ];
arr.forEach(function(item,index) {
new_arr.push(item)  };
4，var new_arr = arr.filter(function(item, index) {
  return item;
  });
5方法五
var new_arr = arr.filter(function(item, index, arr) {
   满足条件的元素要返回
   条件成立的话（true ,false），会把满足条件的元素返回；
  直接使用的元素，隐式转化；
  return arr.indexOf(item) != -1;
  });
```

```js
数组的遍历 (数组遍历)
forEach(function(val, index, arr))	循环遍历数组
filter(function(val, index, arr))	筛选数组符合条件的 ，return出返回条件的元素  成为新的数组
some(function(val, index, arr)) 	查找符合条件的  找到就终止函数 返回值为布尔值
every(function(val, index, arr))    
```

1. arr.forEach

   ```js
   var arr = ['red','blue','yellow'];
   			// forEach：遍历数组
   			arr.forEach(function (val, i, shuzu) {
   				// 第一个参数：当前项
   				// 第二个参数：当前索引值
   				// 第三个参数：数组本身
   				console.log( val, i, shuzu );
   			});
   ```

   

2. arr.filter

   ```js
   var arr = [123,435,546,34,567,66,99];
   
   			// 筛选：筛选后返回一个新数组
   			var newArr = arr.filter(function (val, i, n) {
   
   				// console.log(val, i, n);
   				// return val % 2 == 0;
   				return val >= 100;
   
   			});
   
   			console.log( newArr );
   
   ```

   

3. arr.some

   ```js
   var arr = [123,34,233,66,77,99,234];
   
   			var newArr = [];
   			var result = arr.some(function (val, i, n) {
   
   				console.log(i);
   				// return val == 66;
   				// return true;
   				if (val == 66) {
   					newArr.push(val);
   					return true;
   				}
   
   
   			});
   
   			console.log(newArr);
   ```

   4. arr.every   

# 字符串方法

```js
var res = str.indexOf("abc");  字符串元素查找
元素存在  返回下标
元素不存在  返回-1

var res_2 = str.charAt(2);    查询下标处的字符，返回字符

var res_3 = str.charCodeAt(0);   返回 下标处的字符的ASCII 码值；

var res = str.concat("--------", '88888');返回新数组  原来数组不变

  
var res = str.substring/slice(0, 3);
第一个参数：截取开始的下标，包括
第二个参数：截取结束的下标，不包括
返回值是截取元素组成的新的数组  不会改变原来数组


var res = str.substr(2, 2);    从下标2开始，截取2个
返回值是截取元素组成的新数组  不改变原来数组


str.trim()  删除字符串两侧的空白符
```

# 数组字符串互转

```
数组转字符串
var arr = ['刘备','关羽','张飞'];
var str = arr.join('|'); 
console.log(str);  //  刘备|关羽|张飞
字符串转数组
var str = '刘备|关羽|张飞';
var arr = str.split('|');
console.log(arr);
```



# 获取元素的方法

```
document.getElementById("id名")  
document.querySelector("css选择器");
$("")

```

# 元素节点获取、修改、添加、删除的属性与方法

```js
父.children	获取父元素下所有子元素的一个集合    伪数组
元素.parentNode	获取父元素
元素.nextElementSibling  	获取下一个兄弟元素
元素.previousElementSibling 	获取上一个兄弟元素
innerHTML	可以获取标签内的HTML结构，也也可以设置HTML结构
innertext 	修改节点内容
document.createElement ("标签名")	创建指定的节点	带引号的新标签名	一个元素对象  需要一个变量接受
父.appendChild（子元素）	指定一个父元素， 从后添加子元素	标签名	
父.insertBefore（新的子元素，某个子元素）	在某个子元素之前，插入新的子元素	新的标签名，从哪里插入的标签名	
父元素.removeChild（子元素）	删除子元素	要删除的子元素	

```

```
$('CSS选择器')用法都可以	直接获取对应的元素
$('li:first')	获取第一个元素 
$('li:last')	获取最后一个元素
$(li:eq(1))	获取第n个元素，索引从0开始
$('li:odd')	获取索引是奇数的元素 
$('li:even')	获取索引是偶数的元素

jQ.parent()/jQ.parents("选择器")	对象的直接父元素/对象的而所有的父元素
jQ对象.children()	直接子元素
jQ对象.find('选择器')	所有的后代元素
jQ对象.siblings('选择器')	获取兄弟元素
jQ对象.nextAll()	获取当前元素之后的所有同级元素
jQ对象.prevtAll()	获取当前元素之前的所有同级元素
jQ对象.hasClass("nav")	判断当前元素是否有某个类名，存在返回true
jQ对象.eq(2)	相当于:eq选择器，索引从0开始
prev 获取前一个兄弟节点
$(this).prev('img')

```

# 类名标签 获取、修改、添加、删除的属性与方法

```

.checked 开关属性	"ck.checked = true;ck.checked = false;"

.nodeName	 返回 DOM节点的标签名（e.target.nodeName ）

.disabled	按钮禁用属性    disabled="true"

data-src	data-src="./images/01.jpg          (img.src= btn_2.dataset.src;)

classList.add("类名1","类名2"...)	给元素对象添加一个或者多个类名，不会影响原来的类名；带引号的类名

classList.remove("类名1","类名2"...)	给元素删除一个或者多个类名，	带引号的类名

classList.toggle("类名")	切换类名	带引号的类名

元素.getAttribute("属性名")	获取属性名下的属性值	带引号的类名

元素.setAttribute("属性名,"属性值)	添加或者修改属性值	带引号的类名属性值

元素.removeAttribute("属性名")	删除某个属性	带引号的类名

var res = window.getComputedStyle(元素对象)； res.width 获取到属性值得字符串"
具体的属性 无论是行内的还是样式设置的

```

```

$('div').css('属性名')    	获取对应属性的值
$('div').css('属性','值')	$('div').css('属性','值')  设置单个样式
$('div').css({'属性'：'值','属性'：’值‘})	  同时设置多个样式
	
$('div').addClass('类名‘);	添加类
$('div').removeClass('类名');	删除类
$('div').toggleClass('类名');	切换类


jQ对象.prop('属性')	获取元素本身固有的属性值
jQ对象.prop('属性', 值)	设置元素本身固有的属性和值
jQ对象.attr('自定义属性');	获取元素自定义属性值
jQ对象.attr('自定义属性', 值);	设置元素自定义属性和值
jQ对象.val()  	 获取 表单控件中的值
jQ对象.val(值) 	 设置 表单控件中的值
jQ对象.text()	获取标签中的内容，特点与原生js中的    innertext 一样
jQ对象.text(值) 	 给标签设置值
jQ对象.html() 	获取标签中的内容，特点与原生js中的    innerHtml一样
jQ对象.html(值) 	给标签设置值，可以设置标签

$('html标签')	创建元素
jQ对象.append(创建的元素)	将创建的元素添加到父元素的结束位置
jQ对象.prepend(创建的元素)	将创建的元素添加到父元素的开始位置
jQ对象.after(创建的元素)	将创建的元素作为当前元素的兄弟元素，在当前元素的后面
jQ对象.before(创建的元素) 	将创建的元素作为当前元素的兄弟元素，在当前元素的前面
jQ对象.remove()	 将当前的元素删除
jQ对象.empty()	将当前元素中的内容清空
jQ对象.html('');	将当前标签内容清空
$.extend(obj1, obj2);
浅拷贝对象
$.extend(true, obj1, obj2)	
深拷贝对象
添加，创建元素的方法
insertAdjacentHTML("追加的位置", 添加的元素)	
    afterbegin 插入元素内部第一个节点之前
    beforeend插入元素内部最后一个节点之后
    beforebegin元素外部的前面
    afterend元素外部的后面


```

# JQ的各种方法

```
jQ对象.show（）	元素显示
jQ对象.hide（）	元素隐藏
jQ对象.toggle（）	元素切换显示隐藏
jQ对象.slideDown（）	元素显示（滑动）
jQ对象slideUp（）	元素隐藏（滑动）

jQ对象.slide.Toggle（）	元素切换显示
jQ对象.fadeIn（）	元素淡入（显示）
jQ对象.fadeout（）	元素淡出（隐藏）
jQ对象.fadetoggle（）	
jQ对象.fadeTo（）	透明度
animate(params,[speed],[easing],[fn])	params：要设置动画的CSS属性 【要以对象的形式设置CSS样式】
jQ对象.stop()	停止动画
jQ对象.index()	获取元素的索引
jQ对象[索引]/jQ对象.get(索引)	jQ对象转化为dom对象
$(dom对象)	dom对象转为jQ对象

```

# JQ的遍历

```js
jQ对象.each(function(index, domElement){ });	如果要遍历页面中的元素使用 jQ对象.each
$.each(object, function(index, element){})	    2. 如果要遍历程序中的数据使用 $.each
$.each($('li'), function(i, element){   })	可以遍历程序中的jq对象

```

# JQ的事件注册

```
$('元素').事件名称(function(){});
$('元素').on(事件名称, function(){});   ---注册一个事件
事件委托
语法：
	$('元素').on('事件名称', '真正执行事件的子元素', function(){})
例如：
	//给ul注册点击事件，但是在执行的时候，是点击每一个li执行的点击事件，委托思想
	$('ul').on('click', 'li', function(){ console.log(123) });
```

# jq的解绑事件

```
语法：
	$('元素').off([事件名称],[执行事件委托元素])

注意：
   	1. 如果off()中没有设置任何参数，代表将该元素身上的所有事件都解除掉
    2. 如果要解除对应的事件，可以设置off('事件名称')
   	3. 如果要解除委托事件，可以通过off('事件名称', '执行事件的元素')
	   例如：
       $('ul').on('click', 'li', function(){}) ---> 通过委托给li注册的点击事件
  	   $('ul').off('click', 'li')  ---> 解除li委托的点击事件

   	4. 如果一个元素只执行一次事件可以通过 one('事件名称', function(){})实现
```



# BOM方法

```
location.href	获取或重新设置地址     location.href = 'https://www.jd.com';

window.onload	页面加载完毕的时候执行                     
var timer = setTimeout(函数,延迟的毫秒数);	一次性定时器（clearTimeout(timer);）
var timer = setInterval(函数,间隔毫秒数);	永久性定时器（clearInterval(timer);）
localStorage.setItem("键",值);  	数据进行本地存储
localStorage.getItem("键");	读取数据  本地读取
localStorage.removeItem("键") 	删除键的值  本地删除
localStorage.clear();	清除本地存储
JSON.stringify(对象); 	将对象（数组）转换为json格式的字符串
JSON.parse(json格式字符串);	将json格式的字符串 转换为 对象

```



# 获取鼠标的坐标

```js
e.clientX e.clientY
鼠标位置，以浏览器可视区域左上角为原点	数值

e.pageX e.pageY	
鼠标位置，以body左上角为原点	数值

元素.offsetLeft	
得到的是某个元素距离他的offsetParent元素的水平距离 marginLeft + left	数值

元素.offsetTop	
得到的是某个元素距离他的offsetParent元素的垂直距离 marginTop + top	数值

元素的offsetParent	
找到一个有定位的父亲元素，如果亲生父亲没有定位，会一直往上找，直到找打有定位的父亲，或者body；

元素.offsetWidth	
border+padding+content（width）	数值

元素.offsetHeight
border+padding+content（height）	数值

元素.clientWidth
盒子内容区域的宽度（content）	数值

元素.clientHeight
盒子内容区域的高度（content）	数值

```

# 注册事件类型

```
onclick	点击事件
onfocus	获取光标
onblur	失去光标
oncontextmenu   页面右键
onmousedown	鼠标按键点下
onmousemove	鼠标移动
onmouseup	鼠标按键弹起
onmouseover	鼠标移入
onmouseout	鼠标移出
onkeydown，onkeyup	键盘按下，键盘弹起
onchange 改变事件
"var box = document.querySelector('.box');
box.addEventListener('animationend',function(){
  console.log(123);
})"	动画结束触发
transitionend	元素的过渡动画结束的时候触发；

```

# 事件对象

```
e.stopPropagation(); 	阻止冒泡
e.preventDefault(); 	阻止默认行为

dom_a.addEventListener('click', function(e) {
    dom_a.setAttribute(""href"", ""javascript = void(0)"")
      });"	阻止a标签跳转
 dom_a.addEventListener('click', function(e) {      return :flase  });	阻止a标签跳转
dom_a.addEventListener('click', function(e) {
    e.preventDefault();
});"	阻止a标签跳转


e.target	目标对象，点到谁就是谁
this	谁注册是就是谁
e.currentTarget	谁注册是就是谁
e.keyCode == 13 （键盘码==回车键）
e.ctrlKey  true  按下ctrl键
```

# 问题型的提示框

```
  confirm()
```

# ES6类和对象的继承

```js
	class Star {
				// 属性
				constructor (uname, age) {
					this.uname = uname;
					this.age = age;
					// console.log(123);
				}

				// 方法，普通函数
				// chang：方法名，函数名
				chang () {
					console.log(this.uname + '唱歌');
				}

				tiao () {
					console.log(this.uname + '跳舞');
				}
			}



类的继承-------------------------------------------------------
class Father {
				constructor (uname, age) {
					this.uname = uname;
					this.age = age;
				}
				qian () {
					console.log('赚他一个亿');
				}
			}
			// 子类
			class Son extends Father{
				
				constructor (uname, age, score) {
					
					super(uname, age);
					this.score = score;
				}
				say () {
					console.log('哇哈哈');
				}
				qian () {
					super.qian();
					console.log('zt两毛钱');
				}
			}
			var obj = new Son('李寻欢', 22, 99);
			obj.qian();
```

# ES5对象的创建（创建对象的方法）

```js
 // 通过字面量   键值对的方式

    var obj = {
        name : "王晓雨",
        age :18,
        sayname : function () {
            console.log(123);
        },
    }
    console.log(obj);
    obj.sayname();



    // 构造函数  通过构造函数创建对象【Object】
    var obj1 = new Object();
    obj1.name = "张三丰";
    obj1.age = 25;
    obj1.say = function () {
        console.log(456)
    }
    console.log(obj1);
    obj1.say();


    // 自定义构造函数    构造函数名要首字母大写

    function Star(usname,age) {
        this.usname = usname;
        this.age = age;
    }
    Star.prototype = {
        constructor : Star,
        chang : function () {
            console.log(852)
        },
        tiao : function () {
            
        },
        rap : function () {
            
        }
    }

    var obj2 = new Star("刘德华",26);
    // console.log(obj2);
    console.log(Star.prototype);
    console.log(obj2.__proto__.__proto__.__proto__)

    // obj2.chang();



```

# ES5的继承

```js
属性的继承
 // ES5
    // 属性的继承 当前调用 被继承函数.call(当前函数this，参数)
    function Father(usname,age) {
        this.usname = usname;
        this.age = age;
    }
    function Son(usname,age,height) {
        Father.call(this,usname,age)
        this.height = height;
    }
方法的继承
// 方法的继承  组合继承
    // 子的原型对象 = 父的构造函数   子原型对象指向构造函数  
    Father.prototype = {
        chang : function () {
            console.log(123);
        }, 
        tiao : function () {
            console.log(456);
        }
    }
    Son.prototype = new Father();
    Son.prototype.constructor = Son;
    
    Son.prototype.rap = function () {
        console.log(789)
    }
    Son.prototype.daqiu = function () {
        console.log(563)
    }
    
    var obj = new Son();
    obj.chang();
    obj.rap();
    obj.daqiu();
```

# 函数的调用方式

```
1. 普通函数【fn()】
2. 对象的方法【对象.方法()】
3. 构造函数【new Fn()】
4. 绑定事件函数【obj.onclick = function () {}】
5. 定时器函数【window.setInterval(function () {},1000)】
6. 立即执行函数【(function () {})()】
```

# this指向

```
普通函数调用	window
构造函数调用	实例对象
对象方法调用	改方法的调用对象
事件绑定方法	事件源
定时器函数	window
立即执行函数	window

1. 定时器 函数中的this 指向window
2. 构造函数 指向当前new出来的实例对象
3. 普通函数 中的this 谁调用指向谁
4. 注册事件时函数中的this指向的是事件源
5. 箭头函数中的this 在定义时指向的是上下文中的this指向
6. 事件处理函数中的this 指向的是 Vue实例对象,,,(通常指向app)
7.  Vue中的箭头函数定义的 methods 其中的this 指向的是window  
```

# 改变函数内部指向（改变this指向）

1. ```js
   fun.call(函数指定的this, arg1, arg2, …参数)	
   用于对象属性的继承  改变函数this指向并执行函数
   
   fun.apply(函数指定的this, [argsArray] 参数数组的形式)
   和数组在一块使用Math.max() 求数组的最大值
   
   fun.bind(thisArg, arg1, arg2, ...)	
   改变this指向  但不执行函数
   
   
   相同点:  都可以改变函数内部的this指向.
   
   区别点:  
   1.call 和apply  会调用函数, 并且改变函数内部this指向.
   2.call 和apply 传递的参数不一样, call 传递参数aru1, aru2..形式apply 必须数组形式[arg]
   3.bind  不会调用函数, 可以改变函数内部this指向
   
   主要应用场景:  
   1.call 经常做继承. 
   2.apply 经常跟数组有关系.比如借助于数学对象实现数组最大值最小值
   3.bind  不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向
   	
   
   
   ```


- call

  ```js
  var fn = {
  			name : '张三丰',
  			taiji : function () {
  				console.log(this);
  			}
  		}
  		// 方法里面的this指向谁：调用者
  		// fn.taiji();
  		
  		var obj = {name : '阿飞'};
  
  		fn.taiji.call(obj);
  ```

- apply

  ```js
  // function fn (a,b) {
  		// 	console.log(this,a,b);
  		// }
  		// var obj = {name : '哇哈哈'};
  		// fn.apply(obj,[888,999]);
  
  		// 数组
  		var arr = [123,45,67,23,546,89];
  		// console.log( Math.max(32,45,56,32,56,68,243,546,45656) );
  		// 改变
  		console.log( Math.max.apply(arr,arr) );
  ```

- bind

  ```js
  // var n = 3;
  			// var n = 3;
  
  			// function fn (a,b) {
  			// 	console.log(this,a,b);
  			// }
  			// var obj = {name : '假冰冰'};
  			// var newFn = fn.bind(obj,123,456);
  			// newFn();
  
  			var btn = document.querySelector('input');
  
  			btn.onclick = function () {
  				// 事件源
  				this.disabled = true;
  
  				window.setTimeout(function () {
  					// window
  					this.disabled = false;
  
  				}.bind(this),3000);
  
  			}
  
  
  			// window.setTimeout()：一次性，延迟性定时器
  			// window.setInterval()：反复性，重复性定时器
  ```

  

# js开启严格模式

- js开启严格模式	"use strict";

# 闭包

- 闭包作用：延伸变量的作用范围。	

```
闭包（closure）指有权访问另一个函数作用域中变量的函数。【很多种解释，都并不权威】

简单理解就是，一个作用域可以访问另外一个函数内部的局部变量。

<script>
	function fn1(){
		// fn1 就是闭包函数
		var num = 10;
		function fn2(){
			console.log(num); // 10
		}
		fn2()
	}
	fn1();
</script>
```

# 打印索引值的三种方法

```js
// 方法一  DOM自定义属性
        for (var i = 0; i < lis.length; i++) {
            
            lis[i].setAttribute("index",i)
            // lis[i].getAttribute("index")
            lis[i].onclick = function () {
                this.getAttribute("index");
                console.log(this.getAttribute("index"))
            }
        }
// 方法2 对象的方法

        for (var i = 0; i < lis.length; i++) {
            lis[i].index = i
            lis[i].onclick = function () {
                console.log(this.index);
                
            }
        }
方法三  闭包的方法

        for (var i = 0; i < lis.length; i++) {
            // 写一个匿名函数的自调用
           (function (index) {
            //    var index = i 
            // 一个作用域访问另一个函数内部的变量 为闭包
               lis[index].onclick = function () {
                   console.log(index);
               }
           })(i)
        }
```

# 对象的深拷贝和浅拷贝

- 拷贝不能直接赋值，对象赋值的是地址

- 浅拷贝：只拷贝最外面一层

```
var obj = {
			name : '张三丰',
			age : 22
		};

		var newObj = {};
		for (key in obj) {
			newObj[key] = obj[key];
		}

		console.log(newObj);
		
es6：新方法

Object.assign(target, sources);

console.log(newObj);
```

深拷贝

```js

			var obj = {
				name : '张三丰',
				age : 22,
				color : ['red','blue','yellow'],
				message : {
					sex : '男',
					score : 99
				}
			}

			var newObj = {};

			function kaobei (newObj, obj) {
				// newObj：空对象
				// obj：拷贝对象
				for (var key in obj) {
					// 如果obj[key]是复杂数据类，就不可以直接赋值
					// 如果obj[key]是数组，遍历数组继续拷贝
					// 再如果obj[key]是对象，遍历对象继续拷贝
					// 求他就直接拷贝
					if (obj[key] instanceof Array) { // 是数组
						// 数组拷贝obj[key] = [数组]
						// 保证obj[key]是一个数组
						newObj[key] = [];
						// 把obj[key]遍历拷贝newObj[key]
						kaobei(newObj[key], obj[key]);
						
					} else if (obj[key] instanceof Object) {// 是对象
						// 对象拷贝
						newObj[key] = {};
						kaobei(newObj[key],obj[key]);
					} else {
						newObj[key] = obj[key];
					}
				
				}

			}


			kaobei(newObj, obj);

			obj.message.sex = '女';

			console.log(newObj);
			console.log(obj);

```

# 递归

```
利用递归求1~n的阶乘

//利用递归函数求1~n的阶乘 1 * 2 * 3 * 4 * ..n
 function fn(n) {
     if (n == 1) { //结束条件
       return 1;
     }
     return n * fn(n - 1);
 }
 console.log(fn(3))
```

```
利用递归求斐波那契数列

// 利用递归函数求斐波那契数列(兔子序列)  1、1、2、3、5、8、13、21...
// 用户输入一个数字 n 就可以求出 这个数字对应的兔子序列值
// 我们只需要知道用户输入的n 的前面两项(n-1 n-2)就可以计算出n 对应的序列值
function fb(n) {
  if (n === 1 || n === 2) {
        return 1;
  }
  return fb(n - 1) + fb(n - 2);
}
console.log(fb(3));


思考题羊村：50人家，每户一只羊
	每户只能看别人家的羊有木有病
	每户只能杀自己家的羊
	第一天，第二天 ,第三天，砰砰砰几声枪响，问杀了几只羊
```

```
利用递归遍历数据

		var data = [
			{
				id : 1,
				name : '家电'
			},
			{
				id : 2,
				name : '服饰'
			}
		];


var data = [{
   id: 1,
   name: '家电',
   goods: [{
     id: 11,
     gname: '冰箱',
     goods: [{
       id: 111,
       gname: '海尔'
     }, {
       id: 112,
       gname: '美的'
     },

            ]

   }, {
     id: 12,
     gname: '洗衣机'
   }]
 }, {
   id: 2,
   name: '服饰'
}];
//1.利用 forEach 去遍历里面的每一个对象
 function getID(json, id) {
   var o = {};
   json.forEach(function(item) {
     // console.log(item); // 2个数组元素
     if (item.id == id) {
       // console.log(item);
       o = item;
  
       // 2. 我们想要得里层的数据 11 12 可以利用递归函数
       // 里面应该有goods这个数组并且数组的长度不为 0 
     } else if (item.goods && item.goods.length > 0) {
       o = getID(item.goods, id);
     }
   });
   return o;
}
```

# 正则表达式测试

```
表达式.test（str）
手机验证
var regtel = /^[1][3|4|5|7|8][0-9]{9}$/;
qq号验证
var regqq = /^[1-9][0-9]{4,}$/;
昵称验证
var nikName = /^[\u4e00-\u9fa5]{2,8}$/;
短信验证
var regmsg = /^[0-9]{6}$/;
```

# 敏感字过滤

```
replace替换
表达式/[修饰符]

g：全局匹配

i：忽略大小写

gi：全局+忽略

屏蔽敏感字符


val = val.replace(/搞基|gay/gi, '**')
```

# Ajax   jQuery的写法

```
$.ajax({
    type: 'POST', //请求方式  有 GET获取 和 POST设置，默认是GET
    url: '接口地址',
    data: { //请求参数
      '参数': '值',
      '参数': '值'
    }, //或 '参数=值&参数=值'
    dataType: 'json', //响应数据格式  常用json  默认是text
    success: function(result) {
      // resule为响应结果
    },
    beforeSend: function() {
      //请求开始之前，需要做什么  (选填)
    },
    complete: function() {
      //请求结束后，执行         (选填)
    }
  })
```

```
$.ajax({
    type: '请求方式',
    url: '接口地址',
    data: '请求参数',
    dataType: '响应数据格式',
    success: function (res) {
        // res就是服务器返回的结果
    },
    beforeSend: function () {},
    complete: function () {},
    contentType: '设置请求头中的content-type的值',
    processData: '是否处理请求参数'
});
```

```
$.get('url', [请求参数], [请求成功后的回调函数], [服务器返回数据的类型]);
```

```
$.post('url', [请求参数], [请求成功后的回调函数], [服务器返回数据的类型]);
```



# 原生Ajax写法

- GET

```
//原生的Ajax请求，使用的是XMLHttpRequest对象提供的API

  // 1、实例化 XMLHttpRequest对象， request 请求
  var xhr = new XMLHttpRequest();
  //2、调用open方法，调用请求方式和url 当有参数时,写在URL后面用?隔开
  xhr.open('GET', '/common/time?username=lisi');
  //3、调用send方法，发送请求，到这一步才开始发送ajax请求
  xhr.send();
  //4、响应过程结束，接收服务器响应的结果
  xhr.onload(function() {
    console.log(xhr.response);
  })
```

- POST

```
// 1、实例化 XMLHttpRequest对象， request 请求
  var xhr = new XMLHttpRequest();
  //2、调用open方法，调用请求方式和url

	// open内的第三个参数为false时，表示为同步ajax，运行到send时，会阻塞后面的代码运行，当收到响应时再运行后续代码   不写默认为true 表示异步(常用)

  xhr.open('POST', '/common/checkUser',false);
  //3、设置请求头，固定的代码  只要写POST就写  相对于GET，多了一行
  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
  //4、设置响应数据格式   属性 默认为text  类似于ajax里的dataType
  xhr.responseType = 'json';
  //5、调用send方法，发送请求，到这一步才开始发送ajax请求
  xhr.send({
    '参数': '值',
    '参数': '值'
  }); //或'参数=值&参数=值'
  //6、响应过程结束，接收服务器响应的结果
  xhr.onload(function() {
    console.log(xhr.response);
  })
```

# FormData  预览选择文件

![](D:\00笔记—来于小雨\00笔记\assets\1571323292899.png)

 **$(".img-thumbnail").attr("src",url);**  把url设置为图片 src 的值

如果需要的内容不在表单元素中  可以使用`formData.append`方法 添加



# 懒加载思路

![](D:\00笔记—来于小雨\00笔记\assets\1571126953761.png)

# 模板引擎

1. 准备一个存放数据的盒子（不是必须的，使用body也可以）
2. 引入template-web.js文件
3. 定义模板（具体语法可以去官网查看），一定要指定script的id和type属性
4. 调用template函数，为模板分配数据，template函数有两个参数一个返回值
   1. 参数1：模板的id
   2. 参数2：分配的数据，必须是一个JS对象的形式
   3. 一个返回值：是数据和模板标签组合好的结果
5. 将 “拼接” 好的结果放到准备好的盒子中（不是必须的，console出来也可以看结果）

![](D:\00笔记—来于小雨\00笔记\assets\1566443384929.png)

```js
<script src="./assets/template-web.js"></script>

<script type="text/html" id="test">
        <h2>{{title}}</h2>
        <p>{{age}}</p>
        <ul>
            <li>{{heroes[0]}}</li>
            <li>{{heroes[1]}}</li>
            <li>{{heroes[2]}}</li>
    </ul>
</script>

<script>
    // 下面的数据是模拟的，相当于ajax请求之后，服务器返回的数据
    var data = {
        title: '模板引擎练习',
        age: 20,
        heroes: ['曹操', '刘备', '李逵', '张飞']
    };
    // 调用template函数
    /*
        var str = template(模板的id, 数据); // 数据必须是JS对象格式
        */
    var str = template('test', data);
    console.log(str);
</script>
```

模板语法

- 输出普通数据（字符串、数值等）

```
// 模板写法
{{var}}

// template函数写法
var html = template('id', {
    var: 'hello world'
});
```

- 条件

```
// 模板写法
{{if age > 18}}
	大于18
{{else}}
	小于18
{{/if}}

// template函数写法
var html = template('id', {
    age: 20
});
```

- 循环

```
// 模板写法
{{each arr}}
	{{$index}} -- 数组的下标
	{{$value}} -- 数组的值
{{/each}}

// template函数写法
var html = template('id', {
    arr: ['apple', 'banana', 'orange']
});
```

# 模板引擎处理响应数据



引入  <script src="./libs/template-web.js"></script>

![](D:\00笔记—来于小雨\00笔记\assets\snipaste_20191020_225230.png)

# 大事件项目

## git版本管理

### 语法

### 添加和提交代码

- 初始化仓库
  
- `git init`
  
- 添加文件   工作区 --> 暂存区

  - `git add .`
  - `git add 文件名`

- 提交更改   暂存区 --> 仓库区

  - `git commit -m"信息"`

- 工作区 --> 暂存区和仓库区

  - `git commit -a -m '说明'`  （如果文件曾经被git管理过，才可以使用这个命令）

  ### 恢复代码

- 暂存区 --> 工作区

  - `git checkout .`

- 仓库区 --> 暂存区

  - `git reset .`

- 仓库区 --> 工作区和暂存区

  - `git reset --hard`

  ### 在历史中穿梭

- 查看每个版本的版本号

  - `git log`
  - `git log --oneline`

- 如何切换（穿梭）到历史的某个版本

  - `git checkout 版本号`

  - `git checkout master` --> 到达最后的版本

    ### 分支

- 查看分支

  - `git branch`

- 创建分支

  - `git branch 分支名`

- 创建并直接切换分支

  - `git checout -b 分支名`

- 切换分支

  - `git checkout 分支名`
  - `git checkout -b 分支名` --> 创建并直接切换分支

- 合并分支

  - `git merge 分支名`  （注意先切换分支，然后在合并）

- 查看状态

  - git status

- 查看所有的分支

  - `git branch`

- 删除分支

  - `git branch -d 分支名`

- 删除之前的

  - 回滚  git reset  --hard 版本号
  - 重新提交  git add . 然后 git commit -m '说明'

  ### 推送本地仓库的文件到远程仓库

  

- 新建远程仓库:

  - 比如`github`,`码云`,`gitlab`等等

- 把本地仓库和远程仓库建立关系。（此时还没有推送）

  - `git remote add 远程仓库地址别名  远程仓库地址`

- ==首次==推送

  - `git push -u 远程仓库地址别名 本地分支:远程分支`
  - 如果本地分支名和远程分支名一样，则可以省略 `:远程分支`

- 后续的每一次推送

  - `git push`

- 注意事项

  - ==首次推送==会弹出一个窗口，让我们填写GitHub的账号和密码

- 删除远程仓库 别名记录
  
  - git remote remove  仓库别名(origin)

### 多人合作

- 仓库拥有者

  - 邀请合作者
  - 再次编写代码，仍然要 ==先拉后推==

- 合作者

  - 克隆远程仓库文件到本地仓库
    - `git clone 远程仓库地址` --> 把远程的文件拷贝到本地
  - 把新写的代码或修改的文件，==先提交到本地仓库==
  - 先拉取代码 
    - `git pull`
  - 推送代码到远程仓库
    - `git push`

  ### 解决冲突

在合并分支 或 拉取代码 的时候，如果出现 `CONFLICT` ，则说明文件有冲突。

解决冲突的办法是，将涉及到的程序员叫到一起，一起来解决冲突。

解决完冲突，然后从新执行 `add` 、 `commit` ,最后在 `push`

![](D:\00笔记—来于小雨\00笔记\assets\1571299936757.png)

## iframe基本使用

src属性引入一个其他的页面

```
 <iframe src="https://www.taobao.com" frameborder="0"></iframe>
```

```
   <a  target="myframe" href="./pages/a.html">去a页面</a>
    <a  target="myframe" href="./pages/b.html">去b页面</a>
    <a  target="myframe" href="./pages/c.html">去c页面</a>
    <br>
    <iframe name="myframe" src="./pages/a.html" frameborder="0"></iframe>
```

- a标签的target可以设置为`iframe`的name属性

- 点击a标签就会把新的页面展示到 `iframe`的内部

1. 页面刷新`window.location.reload()` 
2. `iframe`嵌套的页面中也有`window` 
   1. 通过`window.parent`获取到外部的window对象
   2. `window.location.reload()`刷新当前页面
   3. `window.parent.location.reload()`  刷新整个页面
3. 页面跳转
   1. `window.location.href='跳转的地址'`

## token    	服务器返回给浏览器的一个`凭证`

1. 登录成功之后:服务器返回的一个加密字段

2. 给浏览器的一个标记信息:需要通过某种方式保存

3. 可以使用本地缓存

   `localStorage.setItem('key',token)`

- 

### 统一携带token

```
$.ajax(
	url:'',
	data:{},
	headers:{
        Authorization:window.localStorage.getItem('token')
	}
)
```

### 统一设置token

- 为了全部都可以生效  在jQuery源代码的底部,添加`$.ajaxSetup`的代码

  - 步骤

  1. 找到`jQuery`源代码
  2. 最下面增加 设置
  3. 统一携带`token`

- 注意

  - $.ajaxSetup 需要在所有请求之前,写在了jQuery的底部
  - 所有页面都会导入就都会生效了

## (后端)会话技术 - cookie(曲奇,甜饼)

> 保存在浏览器中的简略信息,容量很小4kb

1. http是无状态的:
2. cookie的作用,解决http不会记录客户端(用户信息)这个缺点
3. 服务器:食堂大妈
4. 浏览器:我们
5. 默认情况下,大妈不会记住你
6. 你要在自己身上记录一些东西,让他成为你的标记

注意:

1. cookie 由`服务器`设置
2. 浏览器`保存`
3. 浏览器会`偷偷的携带`到服务器
4. 容量4kb,大数据存不了

![1572506455026](D:/A%E5%B0%B1%E4%B8%9A%E7%9F%A5%E8%AF%86/03-Node.js/Node.js-Day06/01-%E6%95%99%E5%AD%A6%E8%B5%84%E6%96%99/assets/1572506455026.png)

## (后端)会话技术 - session

> 浏览器中保存了一个钥匙,服务器中保存了具体的值

![1572508459037](D:/A%E5%B0%B1%E4%B8%9A%E7%9F%A5%E8%AF%86/03-Node.js/Node.js-Day06/01-%E6%95%99%E5%AD%A6%E8%B5%84%E6%96%99/assets/1572508459037.png)

1. session保存的位置是:服务器
2. 格式是 key:value
3. 浏览器中保存了一个`cookie`(标记,钥匙)
4. 浏览器再次请求服务器时,自动携带标记去服务器,服务器就可以根据标记获取到对应的详细信息了
5. `session`理论上来说,可以存很多的东西

补充

1. 内存:
   1. 程序运行的时候,数据所在的位置
   2. 断电就没有了
   3. 用记事本写笔记,没有保存
2. 硬盘:
   1. 保存的数据关机还在
   2. 保存成文件之后,就会在硬盘常驻



## (补充) token

> 现在比较流行的状态维持方案

1. 占用服务器的内存,消耗性能,存满了,可能会重启

2. `cookie`,`session`都必须依赖于浏览器

3. 应用程序也需要保存状态,但是他们不支持`cookie`,`session`

4. 使用`token`这个技术来实现的

   1. `token`是有服务器生成,基于某种`加密算法`来生成
   2. 计算时,会用到用户的的一些信息,不同用户算出来的值,不相同
   3. 计算完毕之后,服务器直接返回给浏览器,服务器什么都不存
   4. 对服务器的性能消耗小

5. 基于`token`的状态维持

   1. `网站可以用`
   2. `app可以用`
   3. 服务器不需要存东西,服务器性能消耗小

6. 对于绝大多数公司

   1. app
   2. 网页
   3. 公众号
   4. 小程序

   ## (后端)express 中间件统一登录判断

   1. index.js的顶部注册中间件
   2. 通过地址约束`/hero/*`所有和英雄相关的逻辑必须登录才可以使用

   ```
   // 自己写中间件
   // 所有
   app.use('/hero/*',(req, res, next) => {
     console.log(req.session);
     if (!req.session.userInfo) {
       console.log('竟然没登录');
       res.send({
         code:402,
         msg:'小样,没登录也想进来调用接口,滚蛋'
       })
     } else {
       // 向后执行
       next();
     }
   });
   ```

## 同步 & 异步

1. 同步,从上向下依次执行
   1. 绝大多数都是同步
2. 异步,同时执行,某段代码的执行,不会阻塞后续代码
   1. 绝大多数的`异步代码`都伴随着回调函数
   2. 定时器,Ajax,
   3. fs.readFIle(path,(err,data)=>{})
   4. hmModel.find('',(err,result)=>{})
3. ![1572513673280](D:/A%E5%B0%B1%E4%B8%9A%E7%9F%A5%E8%AF%86/03-Node.js/Node.js-Day06/01-%E6%95%99%E5%AD%A6%E8%B5%84%E6%96%99/assets/1572513673280.png)

## echarts 基本使用

> 数据可视化,数据变成图标

1. 常见的,柱状图,饼状图,折线图,
2. k线图
3. 网页绘图
   1. 可以用html元素来绘制,非常不建议,
   2. `canvas`:
      1. 网页中推出的一套绘图api
      2. 画圆,画方,划线....
      3. 公司中
         1. 要么完全不用
         2. 要么用十分会用的牛人,甚至自己封装了一套
   3. `webgl`:
      1. 更接近与底层的绘图api
      2. 相比`canvas`性能更好,
4. 图形化绘制:
   1. 不需要自己学习整套api
   2. 用现成的即可: https://www.echartsjs.com/zh/index.html 
5. echarts:公司使用
   1. 重度使用:大量用到了数据可视化,各种配置都可能会用到
      1. 招聘要求中,明确要求你会`echarts`
   2. 轻度使用:产品经理发现要用的时候,先去`echarts`的官网看看有没有示例,有就用
      1. 随用随看
   3. 大伙不需要花大量的经历在上面
6. 入门方式:
   1. 找示例
   2. 修改内部的代码,看效果
   3. 去配置项中确认效果
   4. 公司中需要大量用到这个

### http.js封装    /* 沙箱模式 */

- 沙箱 可以理解为是一个 独立的环境 js中 值的是 自调用函数(自执行函数)内部写多少变量 都不会影响到外面也不会出现 增加了一堆的全局变量 造成 全局变量污染

  沙箱的用法     外部 自调用函数包裹内部的顶端 声明一堆的变量

  ​                        内部写一些逻辑

  ​      最后 把需要让外部访问的东西 主动的暴露出去

```
/* 沙箱模式 */
(function(w){
    var baseURL = 'http://localhost:8080/api/v1'
    var BigNew = {
        baseURL:baseURL,//基地址
        user_login:      baseURL + '/admin/user/login',//用户登录
        user_info:       baseURL + '/admin/user/info',//用户信息
        user_detail:     baseURL + '/admin/user/detail',//用户详情
        user_edit:       baseURL + '/admin/user/edit',//用户编辑
        category_list:   baseURL + '/admin/category/list',//文章类别查询
        category_add:    baseURL + '/admin/category/add',//文章类别新增
        category_search: baseURL + '/admin/category/search',//文章类别搜索
        category_edit:   baseURL + '/admin/category/edit',//文章类别编辑
        category_delete: baseURL + '/admin/category/delete',//文章类别删除
        article_query:   baseURL + '/admin/article/query',//文章搜索
        article_publish: baseURL + '/admin/article/publish',//文章发布
        article_search:  baseURL + '/admin/article/search',//文章信息查询
        article_edit:    baseURL + '/admin/article/edit',//文章编辑
        article_delete:  baseURL + '/admin/article/delete',//文章删除
        comment_list:    baseURL + '/admin/comment/search',//文章评论列表
        comment_pass:    baseURL + '/admin/comment/pass',//文章评论通过
        comment_reject:  baseURL + '/admin/comment/reject',//文章评论不通过
        comment_delete:  baseURL + '/admin/comment/delete',//文章评论删除
    };

    //暴露接口
    w.BigNew = BigNew;
})(window);
```

- 常规写法

  ```
   <script>
   // 自调用函数创建一个密闭的环境
     沙箱不能去主动的影响外部的世界 为了保证沙箱的封闭  传入window  定义形参接收window 
       使用传入的window不是主动的去外部作用域去获取了       
       代码压缩 形参可以改名字 全局变量window不能更改          
          (function (w) {
          // (function () {
              // 基地址
              var baseURL = "基地址";
              var userLogin = baseURL + "登录";
              var userInfo = baseURL + "信息"
  
              // 暴露出去一个对象
              // window 并没有声明
              // window.urls = {
              w.urls = {
                  userLogin: userLogin,
                  userInfo: userInfo
              }
              
          })(window)    
          // })()    
          console.log(window.urls);
      </script>
  ```

  

## 知识点-$.ajaxSetup全局设置

1. 设置一次之后

2. 所有的Ajax请求都会应用这里的设置

3. 避免代码冗余

   ```
      // ajax全局设置
           $.ajaxSetup({
               headers:{
                   // 随意设置一些内容 
                   itheima:"blackhorse",
                   good:"good study dd up"
               },
               error:function(backData){
                   console.log("错误");
                   console.log(backData)
               }
               // success 如果单个请求中设置了success 全局的会被覆盖
               // success:function(){
               //     console.log('全局设置的success')
               // }
           })
   ```

   ## 知识点-本地图片预览

   步骤

   1. 表单元素的change事件
      1. 获取文件 `this.files[0]`
      2. 生成一个URL地址 `URL.createObjectURL()`
      3. 把地址设置给img `.src`

​       注意

1.   `this.files`伪数组

   1. 有`length `可以通过`索引`取值
   2. 本质是一个对象

   ```
   <body>
       <input type="file">
       <br>
       <img src="" alt="">
       <script>
           document.querySelector('input').onchange = function () {
               // console.log(this.files)
               var file = this.files[0];
               // 生成url
               var url = URL.createObjectURL(file);
               //var url = URL.createObjectURL(this.files[0]);
               // console.log(url);
               // 设置给img
               document.querySelector("img").src=url;
           }
   
       </script>
   </body>
   ```

   

## sessionStorage 和 `localStorage`

- 语法和`localStorage`一模一样

  - `setItem`

    `getItem`

    `removeItem`

- 区别
  - 保存数据的时长不同
    - `localStorage`不删除一直在    保存的数据量大
    - `sessionStorage`关闭浏览器就清除了    保存的数据量小

```
 window.sessionStorage.setItem("secret", "就不告诉你!嘿!");
            // 获取
            // window.sessionStorage.getItem()
            // 移除某一个
            // window.sessionStorage.removeItem()
            // 清空 用的很少
            // window.sessionStorage.clear()
```

## 知识点 隐藏域 

- `隐藏域``input type='hidden'`    藏起来的文本框  用于储存`id`等  

  

## 静态页面的数据传送 分解地址中的信息

```
页面1
<body>
<a href="./second.html?name=jack&age=18&love=rose&skill=swim&friend=robot">去页面2</a>
</body>
页面2
<body>
    <h2>我也页面2</h2>
    <script>
        // // 获取在url后面的数据
        // //second.html?name=jack&age=18 

        // // 如何获取
        // // 专门的属性
        // // ?及之后的数据  ?name=jack&age=18 
        // console.log(window.location.search);

        // // 解析数据 从1开始到最后  name=jack&age=18 
        // var dataStr = window.location.search.slice(1);
        // // console.log(dataStr);

        // // 以&作为分隔符 ['name=jack','age=18']
        // var dataArr = dataStr.split('&');
        // // console.log(dataArr);

        // // key和value分开
        // // 定义数据对象
        // var searchData = {};
        // for (var i = 0; i < dataArr.length; i++) {
        //     // 获取每一项
        //     var eachData = dataArr[i].split('=');
        //     // console.log(eachData);
        //     // 添加到对象中
        //     searchData[eachData[0]] = eachData[1];
        // }
        // console.log(searchData);

        // 抽取为方法
        function formatData() {
            // 去?
            var dataStr = window.location.search.slice(1);
            // 切割为`key=value`的数组
            var dataArr = dataStr.split('&');
            // 生成数据对象
            var searchData = {};
            for (var i = 0; i < dataArr.length; i++) {
                // 获取每一项
                var eachData = dataArr[i].split('=');
                // console.log(eachData);
                // 添加到对象中
                searchData[eachData[0]] = eachData[1];
            }
            return searchData
        }

        var data =  formatData();
        console.log(data);
    </script>
</body>

```

## 网址 安全https://www.sec-wiki.com/skill/2

# 插件       ES6 node.js

## 分页插件

插件文档地址:http://josecebe.github.io/twbs-pagination/

## jeDate插件 时间插件

官网地址: http://www.jemui.com/uidoc/jedate.html 

## wangEditor  富文本插件

官网地址: [http://www.wangeditor.com](http://www.wangeditor.com/) 

## ES6  

`ES6`的改变最大,新功能最多  

阮一峰ES6教程: http://es6.ruanyifeng.com/      不适合新手入门

## Node.js - fs模块基本使用   用来读写

文档地址: http://nodejs.cn/api/fs.html 

1. 文件基本读写会用即可
2. `const fs = require('fs')`
3. `fs.readFile`
4. `fs.writeFile`

## Node.js - 第三方模块

1. 官方的网站(包,模块管家的搜索界面): https://www.npmjs.com/ 
2. 找包 官方的包检索网站`npm`
3. 下包:模板的网页中有命令`npm i xxx`
4. 导包:文档中也有
5. 用包
6. 文档中都可以找到

## 知识点   清屏的命令

小黑窗中输入`cls`

输入了`node`回车 如何退出? `ctrl+c`两次

## ES6 - 函数默认值

1. 调用函数时,不传递参数,参数可以有一个默认值
2. 早期会使用短路运算来实现默认值的设置

```js
// es6中的默认值
// 参数=默认值
// 不传递参数直接使用默认值,传递了参数使用传递的值
function sayHi(name='路飞',skill='橡胶果实') {
    console.log(name,skill);
}
// sayHi();
sayHi('索隆','迷路');
```

## ES6 - 对象解构(使用频率挺高)

更方便的对象属性取值

```
// 定义对象
const person = {
    name:"食戬(jian)之灵",
    desc:"美食番,教你做饭",
    spec:"食物越好吃,衣服就越少"
}
// const name = person.name;
// const desc = person.desc;
// const spec = person.spec;

// 解构赋值
// skill undefined 上面没有定义
// const {name,desc,spec,skill} = person;
// 也可以只获取某一些
const {name} = person;
```

## ES6 - 对象解构实际应用

结合函数用起来挺过瘾的

- 函数的参数解构

  ![](D:\00笔记—来于小雨\00笔记\assets\1571803973215.png)

- 函数的参数解构结合默认值

```
 function eatFood({food1="西兰花炒蛋",food2="西红柿炒蛋",food3="韭菜炒蛋",food4="黄瓜炒蛋"}) {
    console.log(food1,food2,food3,food4);
}
```

## ES6 - 数组解构(了解)

```
// 数组
const cartoonArr = ['喜洋洋','熊出没','铁甲小宝','天线宝宝','海绵宝宝','中华小当家'];

// 取值
// const c1 = cartoonArr[0];
// const c2 = cartoonArr[1];
// console.log(c1,c2);

// 解构
// 获取的顺序 和数组的的元素的对应关系是一致
// 数组大部分时候都是通过下标获取某一个
// 数组的解构用的 不多 了解即可
const [c1,c2,c3,c4,c5,c6] = cartoonArr;

console.log(c1,c2,c3,c4);
```

## ES6 - 对象展开

```
// 对象
const person = {
    skill:"跳水",
    habbit:"抗冻"
}
const student ={
    sleep:"呼噜呼噜!!",
}

const son ={
    // 写在前面的同名属性会被覆盖
    // skill:"游泳",
    ...person,
    ...student
    //  sleep:"呼噜呼噜!!",
    // skill:"跳水",
    // habbit:"抗冻"
}
```

## ES6 - 数组展开

```
// 数组
const vegetables =["西兰花","西红柿","苦瓜","菜花"];
const meats =["牛肉","羊肉","驴肉","鸭肉","鸡肉"]


// 把数组展开
const foods =[...vegetables,...meats];
// const foods =["西兰花","西红柿","苦瓜","菜花","牛肉","羊肉","驴肉","鸭肉","鸡肉"]

console.log(foods);
```

- 数组不会出现覆盖问题,索引会依次向后

## ES6 - 箭头函数

1. 省略`function` 变为`=>`
2. 如果形参`只有一个`,可以省略小括号
3. 如果函数体`只有一行`,可以省略大括号
4. 如果函数体`只有一行`,并且`有返回值`
   1. `省略大括号`的同时,必须省略`return`

```javascript
// 函数 无参数,无返回值的函数
// const func1 = function() {
//   console.log('函数1');
// };
// 省略 function
// const func1 = ()=>{
//     console.log('函数1');
// };

// 省略大括号
// const func1 = ()=>console.log('函数1');

// func1();

//有一个参数,无返回值的函数
// const func2 = function(name) {
//   console.log(name + '你好吗!');
// };

// 省略 function
// const func2 = (name) => {
//   console.log(name + '你好吗!');
// };

// 省略 小括号
// const func2 = name => {
//   console.log(name + '你好吗!');
// };

// 省略大括号
// const func2 = name => console.log(name + '你好吗!');

// func2('rose');

// 有一个参数,又返回至的函数
// const func3 = function(name) {
//   return name + ' 哦哈哟!';
// };

// 省略function
// const func3 = (name)=>{
//     return name + ' 哦哈哟!';
//   };
// 省略小括号
// const func3 = name => {
//   return name + ' 哦哈哟!';
// };
// 省略大括号,有返回值时,必须一起省略 return
// const func3 = name => name + ' 哦哈哟!';

// const res = func3('菜花');
// console.log(res);

// 参数有多个,函数体有多行的函数
// const func4 = function(name, age) {
//   console.log(name + ' 阿尼阿瑟哟');
//   console.log(`你竟然${age}岁了`);
// };

// function 省略
const func4 = (name, age) =>
 {
    //  如果非要省略大括号,只有第一行会当做函数内部的代码
  console.log(name + ' 阿尼阿瑟哟');
    // 第二行开始就和上面的函数没有关系了
  console.log(`你竟然${age}岁了`);
};
func4('路飞',18);

```

## ES6 - 箭头函数中的`this`

> 不再是调用的时候确认`this`,变成创建的时候确认`this`

1. 箭头函数的this 在创建时就确定了 是上下文(和他平级的环境中)中的this
2. 可以通过 `babel`的工具把高级的js代码翻译成低版本的js,查看内部的实现套路
3. babel传送门: https://www.babeljs.cn/ 

![1571816159485](D:\00笔记—来于小雨\00笔记\assets\1571816159485.png)

## 两个路径相关的全局变量

- `全局变量`不需要定义,直接就可以使用

- ```
  __dirname // js文件所在文件夹的绝对路径
  __filename// js文件的绝对路径
  ```

  

## Path模块基本使用  用来获取路径

> 专门用来处理路径的模块

文档传送门:http://nodejs.cn/api/path.html

```javascript
path.extname('info/novel.txt');// 获取文件的扩展名 .txt
path.dirname('info/novel.txt');// 获取路径中文件夹的部分 info/
path.join(路径1,路径2,路径3...);// 把多个路径拼接到一起,保证格式正确
```

其中重点掌握`path.join`即可

```javascript
// 使用fs模块和path模块完成文件的读取
// 导入模块 fs
const fs = require('fs');
// 导入模块 path
const path = require('path');

// 生成绝对路径 path.join
const fullPath = path.join(__dirname,'./novel/01.txt');

// 读取文件
fs.readFile(fullPath,'utf-8',(err,data)=>{
    if(err==null){
        console.log(data);
    }
})
```

注意

1. `\`转义符 需要注意
2. `path.join(路径1,路径2)`不要写成 字符串拼接`+`
3. 使用绝对路径的目的是`保证一定可以获取到文件`

## http模块-创建服务器

使用步骤

1. 导包(内置模块,模块名叫`http`)
2. 调用`createServer`方法创建服务器对象
3. 开启服务器(监听端口)`listen`

概念解释:

` http://192.168.156.65:8848/ `

```
http://  协议: http模块开启的服务是http服务访问的时候带上 `http://`
192.168.156.65:ip地址,花姐的电脑在当前这个局域网中的ip地址 
打开黑窗 输入 ipconfig 
:8848  端口号
```

## http模块 - 服务器的交互流程

```
// 导入内置http模块
const http = require('http');

// 创建服务器对象
const server = http.createServer(function(request,response){
    // 返回内容
    response.end('nice to meet you!! ^_^');
})

// 开启服务器 开启监听
// 参数1 端口号
// 参数2 监听的地址 省略的话就是本机,
// 参数3 开启之后的回调函数
server.listen(8848,function(err){
    if(err==null){
        console.log('开启成功了哦!^_^');
    }else{
        console.log('哎呀,失败啦!');
    }
})
```

![](D:\00笔记—来于小雨\00笔记\assets\1571972568596.png)

## http模块-响应

- 响应英文

  ```
  response.end('abc')
  ```

- 响应中文    网页

  ```
  对于中文需要额外的设置响应头
  // 获取请求的url地址，中文转码
    const requestUrl = decodeURI(request.url);
    
  响应网页  
    // 创建服务器对象
  const server = http.createServer(function(request,response){
  
      // 解决中文乱码 返回一个格式
      // content-type内容类型
      // text/plain 普通文本
      // charset=utf-8 编码格式
      response.setHeader('content-type','text/plain;charset=utf-8');
      // 返回内容
      // response 返回的英文内容可以被正常解析
      // response.end('nice to meet you!! ^_^');
      response.end('怎么老是你！');
  })
  ```

  ## http模块-获取请求url

  > 请求是可以携带信息,如何获取这些呢?

  1. 在回调函数中可以通过`request.url`获取在url中的信息
  2. `request`请求的意思
     1. 会吧请求的信息都保存在这个对象中
     2. `url`就是请求的地址
  3. 如果`url`中有中文，可以通过`decodeURI()`进行转码

  ```
  // 导入http模块
  const http = require('http');
  
  // 创建服务器
  const server = http.createServer((request,response)=>{
      // 打印内容
      // console.log('有人请求我哦！！');
      // 打印请求的地址
      // console.log(request.url);
      // decodeURI url中文解码
      console.log(decodeURI(request.url));
      response.setHeader("content-type",'text/plain;charset=utf-8');
      response.end("辛苦了");
  })
  
  // 开启服务器
  server.listen(4399,function(err){
      if(err==null){
          console.log('开启成功了哦');
      }
  })
  
  根据url响应不同的内容
  	1. 获取请求的url`request.url`
      2. 根据不同的`url`返回不同的结果
  ```

  

-   http模块 - 静态资源服务器

  作用

  1. 开启服务之后，可以通过浏览器输入`http://地址:端口`访问
  2. 如果输入的地址后面还更有网页，可以读取对应的文件并返回
  3. 如果请求的是`css`,`js`,`img`也可以正常返回
  4. 读取文件是，不要设置编码格式为`utf-8`

- 静态资源服务器 - 访问注意

1. 保证 js文件同级目录下有一个`web`文件夹，内部有网页

2. vscode每次 右键打开终端，会新建一个小黑窗

3. 快速访问自己的服务器

   1. http://localhost    本机
   2. http://127.0.0.1     本地回环地址

4. 让同局域网的人访问必须通过本机`ip`才可以

   

##  nodemon(可选)

node 的一个 `全局模块`

当做一个没有图形化界面的软件

安装了之后可以自动检测文件修改，自动重新运行

1.  任意位置执行`npm i nodemon -g`
2.  安装完毕之后
    1. `node xxx`
    2. 换成
    3. `nodemon xxx`

## http模块 - 获取请求的方法

1. `request.method`获取请求方法（  ‘get’    'post'）
2. 结合请求地址的判断，可以自行不同的逻辑
3. 更为复杂的逻辑，不太适合用原生的编写，比较繁琐

## 第三方模块使用步骤

1. 新建文件夹(不要中文)
2. 初始化  打开终端输入:`npm init -y`或者`npm init` 自行输入
   1. 生成一个`package.json`文件
   2. 文件保存了项目的信息，比如版本，名字，使用的第三方模块名...
   3. `npm init `自行输入每一项（初期用的不多）
3. `npm网站`找包
4. 根据提示 下包 `npm i 包名`
   1. `package.json`中 增加一个`dependencies`把下载的包名，记录进去，和版本信息
   2. 文件夹下多
      1. `node_modules`所有下载的第三方模块都会在里面
      2. `package-lock.json`：模块名，版本号，在线地址等。。
         1. 为了让我们第二次下载的时候速度更快
5. 根据提示 导包
6. 根据提示 用包



第二次下载

1. 保存`package.json`及`package-lock.json`有之前下载的模块名

2. 直接输入`npm i`自动读取用到的模块，并下载

   

## express 基本使用

- 相比于原生http模块，开发速度更快的web开发框架

传送门1:http://www.expressjs.com.cn/

传送门2:http://expressjs.com/

1. 初始化:`npm init -y`
2. 下载express:`npm i express`
3. 导入`express`
   1. c+v
4. 使用`express`
   1. c+v
   2. http模块的方法都可以用，但是更建议用`express`的



## express - 托管静态资源

> 一行代码让外部可以访问指定的文件夹

传送门: http://www.expressjs.com.cn/starter/static-files.html 

![](D:\00笔记—来于小雨\00笔记\assets\1572055329726.png)

```javascript
// public文件夹下的文件就可以被访问了
app.use(express.static('public'))
```

## express - get路由

> get请求时，url地址  和   后台函数(逻辑)的对应关系

接口调用 

1. 浏览器`调用` 定义在`服务器的函数`

## express - get请求参数获取

1. get请求的参数放在那里 `url?key=value&key2=value2`
2. `key`接口文档提供给我们的
3. `value`前端准备好的
4. get请求的数据全部都放在`request`中
5. ![](D:\00笔记—来于小雨\00笔记\assets\1572063759714.png)

重点

1. url中的数据通过`request.query`来获取

## express - post路由

> post请求时，url和后台函数的对应关系

```javascript
app.post('/地址',function(request,response){})
```

注意

1. post路由的注册方法 和get类似，名字变为`post`
2. 直接通过浏览器的url访问发送的是`get`
3. 可以通过`postman`发请求
4. 自己写ajax设置请求的`type`为post
5. 默认注册的post路由中无法获取到提交过来的参数(数据)

## express - post数据获取（普通文本）

> 通过express的`中间件` 获取post提交的文本数据

传送门: https://www.npmjs.com/package/body-parser 

1. 中间件是一个特殊的第三方模块
2. 必须结合`express`才可以使用
3. 类比为`jQuery`插件

![1572075812290](D:/A就业知识/03-Node.js/Day03/01-教学资料/assets/1572075812290.png)

使用步骤· 下包  导包  用包

## express - post文件提交

> express通过第三方中间件来获取上传的文件

传送门: https://www.npmjs.com/package/express-fileupload 

1. 下包

2. 导包

3. 用包

   1. `request.files` 保存了所有文件信息

   2. `request.files.xxx` 获取 key为`xxx`的文件信息

   3. `request.files.xxx.mv（路径，回调函数）`把文件移动到某个地方

      #                 		跨域

      

## 跨域

> 不是什么接口都可以直接调用成功的哦，比如跨域的接口

![1572224645119](D:/A就业知识/03-Node.js/Node.js-Day04/01-教学资料/assets/1572224645119.png)

1. `Ajax请求`不同源接口的时候会出现
2. `浏览器`为了保护我们帮我们做的限制
3. 浏览器打开的页面，和调用的接口需要`同源`才可以调用

## 浏览器同源

> 协议，地址（域名），端口 任意一个不相同就是跨域呢

传送门: https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy 

url地址的组成:` http://127.0.0.1:3000/search `

	1. 协议:`http://`

   	2. 地址(ip):`127.0.0.1`
            	3. 端口:`3000`

![1572225251368](D:/A就业知识/03-Node.js/Node.js-Day04/01-教学资料/assets/1572225251368.png)

同源:

1. 浏览器打开的页面地址:
   1. http://127.0.0.1:5500/02.cross-origin/index.html 
2. 页面同Ajax调用接口的地址:
   1. http://127.0.0.1:3000/search
3. 协议，地址，端口全部相同，称之为`同源`，
   1. 页面地址和接口地址同源，浏览器就不会做任何的限制
   2. 可以自由访问
4. 协议，地址，端口任何一个不相同`不同源`
   1. 浏览器默认是禁止访问的
5. 实际工作中，不可避免页面地址和接口地址绝对同源
   1. 肯定有解决方案
   2. 常用的有两种
      1. `cors`:目前用的最多的
      2. `jsonp`:曾经最多的，现在越来越少，面试喜欢问
6. 往不同源的接口发请求，`跨域`

## 跨域方案 - jsonp

>  JSON with Padding 利用了src属性支持跨域访问实现的跨域请求哦
>
>  虽然是民间方法，但是也成为了一个大伙约定俗成的标准了

1. 民间的解决方案
2. 使用方式:
   1. 前端：
      1. $.ajax
         1. url
         2. type:必须是get
         3. success:function(backData){}
         4. dataType:'jsonp'
   2. 后端:
      1. `response.jsonp({key:value,key2:value2})`

注意：

1. 如果接口是jsonp
2. 前端要干的事
   1. dataType:'jsonp',
   2. type:'get' 或者省略
   3. 数据的发送，请求成功之后的回调函数 和之前完全一样
3. 后端代码，工作中不用我们写
4. jsonp接口文档
   1. 请求地址: `接口地址`
   2. 请求方法：`jsonp`  （type:`get`,dataType:`jsonp`）
   3. 参数：`键值对`

## jsonp原理（面试会碰到）

> 虽然这个方案现在用的越来越少，但是面试还是挺爱问的

1. script标签的src属性，可以发送请求，没有`同源限制`
2. 和`Ajax`一点关系都木有：
   1. `network`中选到`xhr`分类，什么都看不到
3. 本质是动态创建了一个`script`标签添加到页面顶部
   1. src设置的:`接口地址`+`发送的数据`+`callback=xxx`
4. 请求成功之后会被自动移除
5. 服务器返回了:函数的调用`函数名({对象})`
6. 内容返回到浏览器之后会被解析为`js`，调用定义好的函数，传入了一个参数

jQuery的jsonp

![1572228409990](D:/A就业知识/03-Node.js/Node.js-Day04/01-教学资料/assets/1572228409990.png)

自己写jsonp

![1572228673181](D:/A就业知识/03-Node.js/Node.js-Day04/01-教学资料/assets/1572228673181.png)

注意：

1. 工作中肯定是用jQ的
2. 自己写需要
   1. 创建标签
   2. 声明函数
   3. 可能还需要自行移除标签
   4. 这些`jQ`都帮你干好了
3. 虽然是民间的解决方案，但是很好用，广大程序员就做好了约定
4. 你必须发送`callback`
5. 后端也是通过`callback`去获取方法名字
6. 缺点:
   1. 不支持`post`请求
   2. 数据大的话，搞不定，文件上传搞不定
7. 流行的原因:
   1. `兼容性`好到令人发指

## 跨域方案 - CORS(目前最为流行的方案)

> 需要后端配合
>
> 目前最为常用的一种跨域解决方案

传送门: https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS 

1. CORS:
   1. cross:跨
   2. origin：域
   3. resource：资源
   4. sharing：共享
2. 目前用的最多的
3. `HTML5`中推出的新标准，低版本浏览器不支持`ie`

用起来简单到令人发指：

1. 前端：什么事不不用干
2. 后端：设置允许跨域
   1. express中：
      1. 响应数据之前：设置一个允许的header
      2. ` response.header('Access-Control-Allow-Origin', '*');`
   2. 无论用什么开发的后端：都需要设置上面类似的内容，才可以允许前端访问



注意：

1. CORS原理：
   1. 浏览器能够识别` ('Access-Control-Allow-Origin', '*');`这个header
   2. 请求发给服务器之后
   3. 服务器返回的响应头中有一个允许的标记
   4. 浏览器就认为服务器允许跨域访问，没有了跨域的错误
2. 缺点：
   1. 兼容性比`jsonp`差一些
   2. 微软已经放弃`xp` `ie5,ie6`基本没人用
3. 优点:
   1. get和post都支持
   2. 前端什么都不用干
4. 无论是jsonp还是`cors`一定需要后端配合
5. 纯前端在`正常情况下无法跨域`

## express - 中间件 设置跨域

> 通过注册一个所有请求都会执行的公共回调函数来统一设置跨域

请求和响应之间额外注册的一个`回调函数` 

1. 在这个回调函数中统一的设置允许跨域的那个头

```javascript
// 自己写 中间件 来运行跨域
app.use((request,response,next)=>{
  console.log('执行啦');
  // 设置运行跨域
  response.header('Access-Control-Allow-Origin', '*');
  // 调用next
  next();
})
```



## express - 中间件

> 刚刚额外注册的那个回调函数就是中间件哦

传送门: http://www.expressjs.com.cn/guide/writing-middleware.html 

```javascript
app.use('地址(可选)',function(request,response,next){
    // request 后续的函数共享这个request对象
    // response 后续的函数共享这个response对象
    // 执行下一个函数
    next();
})
```

1. 中间件是请求和响应之间额外注册的回调函数
2. `request`和`response`是共享的
3. 中间件中为`request`对象额外增加的属性
4. 在后续的回调函数中可以获取到
5. 中间件可以增加`任意个`
6. `next`如果不调用，卡主，浏览器接收不到数据
7. 在请求和响应之间，额外注册的回调函数
8. `请求`--`回调函数（中间件）1`---`回调函数（中间件）2`------->`响应`
9. 执行的顺序从上到下依次执行
10. 编写的位置路由的前面
11. 从上往下依次执行
12. ![1572232444359](D:/A就业知识/03-Node.js/Node.js-Day04/01-教学资料/assets/1572232444359.png)

注意:

1. 中间件是回调函数
2. 请求和响应之间额外注册的回调函数
3. 请求和响应之间根据注册的顺序依次执行
4. `next`调用了才会继续执行
5. `请求(request)`和`响应(response)`对象`共享`

## node.js 模块化

> node.js中模块的抽取必须要遵守特殊的语法哦

传送门-`CommonJs`标准：<http://www.commonjs.org/>

* 1.世界上的编程规范有很多种，CommonJS只是其中一种
* 2.CommonJS规范不是只为Nodejs服务，有很多平台都遵循CommonJS规范，Nodejs平台只是其中之一
* 3.CommonJS规范只有三句话
  * 1.导入模块使用:`require()`
  * 2.导出模块使用:`module.exports`
  * 3.导出模块一定要使用:`module.exports`(重要是事说两遍)



注意：

1. 导入模块`require`
   1. 自己的模块写路径
   2. `.js`可以省略

2. 模块暴露`module.exports`
   1. 类似自调用函数底部`window.xxx=值`
   2. 暴露多个，用对象方式
   3. 重复为`module.exports`赋值后面的会把前面的覆盖
3. 抽取的模块不需要运行
4. 导入的时候内部的代码会自动解析
5. `module`是关键字，全局变量
6. 要用哪个属性，就点哪个属性

## 自己写计算器模块

注意

1. 写功能
2. 暴露出去`module.exports={add,sub,mul,divi}`
3. 导入模块:`computer`
4. 使用方法:`computer.add(10,7)`

## 跨域模块抽取

> 刚刚的中间件抽取为一个独立的模块，哪里都可以用哦

步骤:

1. 创建了一个文件夹`utils`

   1. 工作中`自己抽取`的功能模块，很多公司都会放在这个文件夹中
2. 创建一个文件
   1. 暴露回调函数
3. 任意一个文件 导入`模块`
4. `app.use(模块)`

自己写的模块

```javascript
// 暴露
module.exports = 
(request, response, next) => {
  console.log('执行啦');
  // 设置运行跨域
  response.header('Access-Control-Allow-Origin', '*');
  // 调用next
  next();
};

```

使用模块

```javascript
// 导包
const express = require('express');
// 导包 自己抽取的模块 跨域
const myCORS = require('./utils/myCORS');
// 创建服务器
const app = express();

// 自己写 中间件 来运行跨域
app.use(myCORS)

// 注册路由 - get
app.get('/corsGET', (request, response) => {

  response.send('/get');
});

// 注册路由 - post
app.post('/corsPOST', (request, response) => {

  response.send('/post');
});

// 开启服务器
app.listen(3000, err => {
  if (!err) {
    console.log('success');
  }
});


```

常见文件夹名:

 1. utils：自己抽取的功能模块

 2. libs:下载的第三方模块（自己手动下载）

 3. node_modules:`npm i 模块名`自动下载的文件夹，内部保存了第三方模块

 4. `static`：静态资源`html,css,js`

 5. public:公共文件（静态资源）

 6. `web`：页面(静态)

    

## 什么是数据库

> 通俗的来说就是数据的仓库，软件来的，保存数据同时，数据的安全性也得以保证

1. 数据库分类:

   1. 关系型数据库：
      1. 类似于`table`表格的形式保存数据
      2. 使用`sql`的语句操纵数据
      3. 常见的有:`MYSql`,`Oracle`,`MSSql`。。。
   2. 非关系型数据库:
      1. 用类似于`js对象`的形式保存数据
      2. 使用操纵对象的形式操纵数据
      3. 常见的有:`Mongodb`,`Redis`。。。
2. 数据库管理员:
   1. DBA:DataBase Admin
3. 数据库服务器:
   1. 只提供数据库服务，其他的都木有

## MySql基本使用

> 建库，建表，增加字段，增删改查

1. MYSql
   1. 免费，
   2. 开源，可以看到源代码，可以修改，可以定制
   3. 轻量级：小
   4. 作为关系型数据库的市场份额比较大
2. 建库（银行开户，有了一个存数据的空间）
3. 建表（一个一个的架子，excel）
4. 建字段（excel的表头）



1. 打开mysql

![1572246095078](D:/A就业知识/03-Node.js/Node.js-Day04/01-教学资料/assets/1572246095078.png)

1. 建库:
2. ![1572246247517](D:/A就业知识/03-Node.js/Node.js-Day04/01-教学资料/assets/1572246247517.png)
3. 建表
4. ![1572246403685](D:/A就业知识/03-Node.js/Node.js-Day04/01-教学资料/assets/1572246403685.png)
5. 建表头
6. ![1572246595765](D:/A就业知识/03-Node.js/Node.js-Day04/01-教学资料/assets/1572246595765.png)
7. 查看数据
8. ![1572246669197](D:/A就业知识/03-Node.js/Node.js-Day04/01-教学资料/assets/1572246669197.png)

## sql语句 - 增（insert）-了解即可

> 数据的新增，也可以叫做数据的插入

```sql
insert into 表名 （字段1，字段2，字段3...） values(值1，值2，值3...)
```

```sql
insert into user (username,skill) values('蔡*坤','唱，跳，rap');
```

## sql语句 - 删（delete）

> 数据的删除，但是正式工作中用的不多，数据可是很珍贵的哦

```sql
delete from 表名 where 条件
delete from user where id=3; 删除一条
delete from user where id <3; 删除范围
delete from user;不跟条件全部被干掉
```

1. 必须给条件，否则全部删除

## sql语句 - 改（update）

> 数据的修改，记得跟上条件

```sql
update 表名 set 字段1=值1, 字段2=值2,..... 条件
update user set username='赵四' ,skill='尬舞' where id = 22;
update user set username='葫芦娃' ,skill='救爷爷' where id > 22;
update user set username='小蝴蝶' ,skill='坑葫芦娃';
```

1. 条件不给全部改变

## sql语句 - 查（select）

> 数据的查询，通过各种条件进行数据的检索

```sql
select * from 表名 条件;
select * from user where id =26; 精确查询
select * from user where id <26;范围
select * from user ;全部
```

1. 和增删改不同，获取到数据本身
2. 增删改只能看到`几条数据`被改变了
3. 数据的基本操作分为4中，增删改    查

## mysql模块使用（了解）

> 通过node.js操纵数据库的第三方模块，了解即可

传送门:  https://www.npmjs.com/package/mysql 

1. 在Node.js中通过`MySQL`模块操纵数据库（间接操纵）数据库
2. 本质还是`sql`比较麻烦

## mysql-ithm模块使用（推荐）

> 黑马程序员开发，轻量级的`orm`( Object Relational Mapping )框架,记得好评哦

通过调用方法的方式，去间接的操纵数据

理论上来说一行`sql`都不需要写

只要会调用方法，你就可以操纵数据

用操纵对象的方式去操纵数据库

底层还是`sql`只不过不用开发人员自己写了

开发的速度更快

也是工作中绝大多数后端使用的开发方式

## 假数据生成 mock.js（明天讲）

> 批量假数据生成

## 补充 - app中没有跨域

1. 绝大多数的`app`也需要和服务器交互
2. 使用的技术不是`ajax`,但是类似
   1. 地址
   2. 参数
   3. 回调函数
3. 因为不是`ajax`没有跨域
4. 一个项目的后端接口可能只有一套
   1. 早期给`app`用
   2. 公司由于业务增加，需要做网页版本
   3. 数据接口之前`app`可以正常使用
   4. 前端调用接口用`ajax`
   5. 不同源就跨域了会报错
5. 有可能后端不知道需要设置跨域
   1. 友善的提示一下
   2. 设置即可

## 补充 - VSCode代码片段

1. 用几个单词，写出一堆代码
2. ![1572251030894](D:/A就业知识/03-Node.js/Node.js-Day04/01-教学资料/assets/1572251030894.png)
3. ![1572251182332](D:/A就业知识/03-Node.js/Node.js-Day04/01-教学资料/assets/1572251182332.png)
4. `prfix`建议加上一个自己独有的前缀，方便记忆

## 拓展阅读 - chrome允许跨域（了解）

* 跨域是浏览器的一个安全限制

* 可以通过修改一些设置，让被设置的浏览器没有这个同源的限制

* 修改之后
  * 1.浏览器明确告诉你 不安全 （不安全，一般没人设置）
  * 2.只有设置的浏览器可以跨域（会主动设置这个应该是`程序员`吧）
* 仅作课后了解即可：https://www.cnblogs.com/laden666666/p/5544572.html

## Mockjs 模拟数据生成（随机数生成）

> Mock模拟数据

1. Mockjs的js库,可以生成随机的测试数据

   http://mockjs.com/

2. Mockjs生成随机测试数据



## 补充 - 快捷键 

1. home,end:行头,行位
   1. mac: fn+左右
2. shift+home或end:选中一行
3. ctrl+左右:识别词组跳跃
4. vscode中快捷键:
   1. ctrl+enter:光标换行,文字不换行
   2. ctrl+shift+enter:光标去上一行,文字不动

 https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf 

#               			                                                Vue

- Vue (读音 /vjuː/，类似于 **view**) 是一套用于构建**用户界面（User Interface）**的渐进式框架

- MVVM框架 => M =>Model 数据 =>V =>View  VM => ViewModel  =>响应式数据 => 数据变化 =>视图变化

- > Vue 的核心库只关注**视图层**，与现代化的工具链（Webpack）以及各种支持类库（Babel、TypeScript）结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。

- Vue 其实就是一个封装了大量逻辑的 Javascript 文 件

#### 视图

- **只能在一定的“范围”才可以生效，我们称这部分为View，即视图层 。** 
  - **注：将 el 指定的区域称为视图并不严禁，准确一点儿应该叫模板，不过初学者不必细究。**

#### 模型

- 一个**网页的核心是数据**，html 和 css 只是负责将这些数据以较为美观的形式展示，**Vue 可以对页面所承载的数据进行管理，我们称之为 Model，即模型。**

#### 数据绑定

- 是指将**视图层DOM元素与模型层中的数据建立一一对应的联系**，将这种联系称为数据绑定。

1. DOM 元素一般包含**属性节点**和**文本节点**

###### 属性节点绑定

1. v-bind:属性名` 是实现属性节点绑定的语法格式。

   ```js
    <!-- 在 vue 中对属性进行数据绑定时，使用 v-bind:属性名="值" -->
    <p v-bind:title="title">一段文本</p>
   ```

2. class` 和 `style` 是DOM元素中比较重要的两个属性。

   ```js
   <div id="app">
     <!-- 在 vue 中对属性进行数据绑定时，使用 v-bind:属性名="值" -->
     <p v-bind:title="title" v-text="title">一段文本</p>
   
     <!--v-bind:style 语法相对特殊一些，接受一个对象类型数据 -->
     <!-- 这个对象的内容都是 css 的代码，{color: 'red', width: '100px'} -->
     <p v-bind:style="{color: red}">我是一段带颜色的文本</p>
   
     <p v-bind:style="styleObject">我是一段带颜色的文本</p>
   
     <!-- v-bind:class 语法相对特殊一些，接受一个对象类型数据 -->
     <!-- 对象的属性为真实存在的 类名 -->
     <!--
   		对象的值为布尔类型，
   		如果为 true 则添加属性对应的类名，
   		如果为 false 则不添加
   	-->
     <p v-bind:class="{demo: true, test: false}">一段文本</p>
   </div>
   
   <script>
     new Vue({
       el: '#app',
       data: {
         title: 'Vue 的属性绑定',
         styleObject: {
           color: 'red',
           backgroundColor: 'blue'
         }
       }
     })
   </script>
   ```

   

3. 

4. 3. v-bind:属性名` 可以被简写为 `:属性名`
   4. 支持 Javascript 表达式

5. 文本节点绑定

   1. `{{}}` 是实现文本节点绑定的语法格式
   2. `v-text` 一般认为是 `{{}}` 的另一种写法，相当于原生 DOM 中的  `innerText`
   3. `v-html` 在渲染时能够解析文本的 `html` 标签，相当于原生 DOM 中的 `innerHTML`
   4. 支持 Javascript 表达式

6. 事件绑定

   1. 事件可以认定为DOM元素的属性，如 `<a href="javascript" onclick="clicked">点击</a>`，但是由于其特殊含义 vue 中将它与其它属性区别对待。
   2. `v-on:事件名="回调函数"` 是为添加事件监听的语法格式

   ```html
   <div id="app">
     <a href="javascript:;" v-on:click="clicked">点击</a>
   </div>
   ```

   3. 回调函数定义在 Vue 实例中的 `methods` 中，如下：

   ```html
   <script>
     // 实例化
   	new Vue({
       el: '#app',
       data: {
         name: '小明'
       },
       // 在此定义的函数，可以充当事件的回调函数
       methods: {
         clicked: function () {
           // 事件被触发时调用
         }
       }
     })
   </script>
   ```

   4. `v-on:事件="回调函数($event)"`  $event 做为参数传递时具有特殊含义，用它获得事件对象

   ```html
   <div id="app">
     <a href="javascript:;" v-on:click="clicked($event)">点击</a>
   </div>
   
   <script>
     // 实例化
   	new Vue({
       el: '#app',
       data: {
         name: '小明'
       },
       // 在此定义的函数，可以充当事件的回调函数
       methods: {
         clicked: function (ev) {
           // 事件对象
           console.log(ev);
         }
       }
     })
   </script>
   ```

   5. `v-on:事件名.修饰符="回调函数"` 通过添加修饰符来实现事件的特殊处理，如事件冒泡等

   ```html
   <div id="app">
     <!-- 嵌套的两个盒子 -->
     <div class="parent" v-on:click="parent">
       <!-- 修饰符 stop 可以阻止冒泡的发生 -->
       <div class="child" v-on:click.stop="child"></div>
     </div>
   </div>
   
   <script>
     // 实例化
   	new Vue({
       el: '#app',
       data: {},
       // 在此定义的函数，可以充当事件的回调函数
       methods: {
         parent: function () {
           // 执行逻辑
           console.log('父盒子被触发了...');
         },
         child: function () {
           // 执行逻辑
           console.log('子盒子被触发了...');
         }
       }
     })
   </script>
   ```

   6. `v-on:事件名="回调函数"` 可以被简写为 `@事件名="回调函数"`

7. 响应式数据绑定

   关于响应式可以理解成一种**自动机制**，即一方发生改变后，另一方也相应做出改变。具体在 vue 中，是指当模型 (data) 中的数据被改变后，所对应的视图区域也会相应改变，而这一切又都是自动完成的。

   ```html
   <div id="app">
    <p>你好{{name}}，欢迎来到传智播客学习IT技术!</p>
     <button @click="changeUser">换个同学</button>
   </div>
   
   <script>
   	var vm = new Vue({
       el: '#app',
       data: {
         // 初始数据
         name: '小明'
       },
       methods: {
         // 事件回调函数
         changeUser: function () {
         	// 对 name 数据修改后，视图中的数据也自动发生改变
           this.name = '小刚';
         }
       }
     })
   </script>
   ```

   

8. 双向数据绑定

   数据绑定有单向和双向之分，具体是指数据的流向。

   1. 单向，模型 ------> 视图
   2. 双向，模型 <------> 视图

   表单元素在 html 中具体特殊意义，它的主要作用并不是展示数据，更多的是收集用户填写的数据，因此表单元素也就成为了数据的提供方了，通过修改表单中的内容，实现模型中 data 数据的变化。

   为表单元素添加 `v-model` 可以实现数据的双向绑定。

   ```html
   <div id="app">
     <!-- v-model 是实现数据双向绑定的关键 -->
     <input type="text" v-model="msg" />
     <!-- 用户在表单中输入内容时，下面 h3 的内容会同步更新 -->
     <h3>{{msg}}</h3>
   </div>
   
   <script>
   	// 实例化
     new Vue({
       el: '#app',
       data: {
         msg: '初始数据'
       }
     })
   </script>
   ```

#### 实例选项

- el
- data
- methods
- watch
- computed
- ....
- 不同的选项具有不同的作用。

### 实例选项 - el

- 不能是 html、body 节点
- el 只能作用到单一节点上

### 实例选项 - data

data 不是普通的数据，这种数据我们称之为**响应式**数据，**用来驱动视图更新的数据**。

注意：

- **模板中访问的数据必须初始化到 data 中**
- **模板无法访问 Vue 实例之外的数据**

```js


const a = 1
    const app = new Vue({
      /**
       * 告诉 Vue 管理视图的入口
       */
      el: '#app',
      /**
       * 这个 data 就好比之前使用 art-template 模板引擎的数据一样的
       * 我们可以直接在被 Vue 管理的视图中使用 data 中的数据绑定
       */
      data: {
        message: 'Hello Vue.js!',
        user: {
          name: '张三',
          age: 18,
          gender: 0 // 0 男，1 女
        },
        todos: ['吃饭', '睡觉', '打豆豆'],
        count: '',
        num: 0, // 数字
        str: '', // 字符串
        isSeen: false, // 布尔值
        arr: [], // 空数组
        /**
         * 对于对象的修改
         * 1. 没有初始化的对象成员如果修改不会更新视图
         * 2. 也有方式可以动态添加未初始化的数据成员并且能更新视图（后面说）
         * 3. 直接对对象进行重新赋值可以实现视图更新
         *   xxx = 新的数据对象，例如 app.obj = { a: 123 }
         * 建议：最好把所有需要的数据都初始化到 data 中来
         */
        obj: {
          // a: 0
        } // 对象，没有初始化的对象成员如果修改不会更新视图
      }
    })
```



#### 结构

- 动态网站的页面结构是根据数据展示的需要动态创建的，**vue 具备动态创建页面结构的能力。

条件控制
1. v-if

2. v-else

3. v-else-if

4. v-show

   ```javascript
   <div id="app">
     本次考试成绩为{{score}}分，成绩等级为
     <span v-if="score >= 80">优秀</span>
     <!-- 条件判断 -->
     <span v-else-if="score >= 70">良好</span>
     <span v-else>及格</span>。
   </div>
   <script>
   	var vm = new Vue({
       el: '#app',
       data: {
         score: 75
       }
     })
   </script>
   ```

   ###### v-if` 和 `v-show

- v-if` 和 `v-show` 在视觉效果上是一致的，然而其实现是有差异的，`v-if` 是通过添加/移除 DOM 节点实现，`v-show` 是通过 css 的 display 属性值（block/none）实现。

- `v-if` 会导致 DOM 树中，节点数量变化，开销方面会更大一些，`v-show` 并不影响DOM中节点数量变化，开销相对低一些。

- 对于操作较为频繁的显示/隐藏操作，建议使用 `v-show`，相反建议使用 `v-if`

- 另外 `v-if` 是惰性的，如果其值为假，则内部所有元素都不会被渲染。

#### `v-for` 实现数组/对象类型数据的遍历

- ###### `key` 管理可复用的元素

  Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。

```javascript
<div id="app">
  <table>
    <tr>
    	<th>序号</th>
      <th>姓名</th>
      <th>性别</th>
      <th>年龄</th>
    </tr>
    <!-- student 和 index 分别可以获取被遍历数据的单元值和索引值 -->
    <!-- <tr v-for="(student, index) in students"> -->
    <!-- 也可以使作 of 实现遍历操作 -->
    <tr v-for="(student, index) of students">
    	<td>{{index+1}}</td>
      <td>{{student.name}}</td>
      <td>{{student.gender}}</td>
      <td>{{student.age}}</td>
    </tr>
  </table>
  <div class="box">
    <!-- 对象数据遍历，u 为对象的 属性值，i 为 对象的 属性 -->
    <span v-for="(u, i) of user">{{i}} => {{u}}</span>
  </div>
</div>

<script>
	var vm = new Vue({
    el: '#app',
    data: {
      user: {
        name: '小明',
        age: 18
      },
      students: [
      	{
          name: '小明',
          gender: '男',
          age: 18
        },
      	{
          name: '小红',
          gender: '女',
          age: 17
        },
        // ...
      ]
    }
  })
</script>
```

1. 当 Vue 正在更新使用 v-for 渲染的元素列表时，它**默认使用“就地更新”的策略**。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。

2. 这个默认的模式是高效的，但是**只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出**。

3. **建议尽可能在使用 v-for 时提供 key 属性**，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。

   > 注意：
   >
   > - 不要使用对象或数组之类的非基本类型值作为 `v-for` 的 `key`。请用字符串或数值类型的值。
   > - 不要使用遍历索引 index 作为唯一的 key 值，会有问题
   > - 一般使用数据中能表示唯一的那个字段，例如id

### 值范围遍历

`v-for` 也可以接受整数。在这种情况下，它会把模板重复对应次数。

```html
<div>
  <span v-for="n in 10">{{ n }} </span>
</div>
```

结果： 1 2 3 4 5 6 7 8 9 10

#### 事件绑定中的event事件对象

```js
<div id="app">
    <!-- 
      函数调用()
      事件处理函数：我们负责注册，系统会在满足这个条件的时候帮你完成调用
      在 Vue 中，所有的事件处理函数都会接收一个默认参数：event 事件对象
      Vue 在调用这个事件处理函数的时候会给你传递一个参数：event 事件对象
      如果你需要，那你就声明形参接收使用
      如果不需要，就不用声明接收
    -->
    <button @click="onClick"></button>

    <!-- 
      如果用户注册函数的时候传递了自定义参数，那么默认的 event 就丢失了
      注意：这里 onClick2(123) 不是调用函数，这是 Vue 注册事件处理函数传递参数的语法
            还是当事件触发的时候才会被调用
    -->
    <button @click="onClick2(123)"></button>

    <!-- 
      如果你自定义传参之后希望能够继续获取到 event 事件对象，那就需要手动的传递 $event
      注意：$event 是一个固定语法，不能乱写
    -->
    <button @click="onClick3(123, $event)"></button>
    <button @click="onClick3($event, 123)"></button>

    <button @click="onClick3"></button>
    <!-- 这两种是等价的 -->
    <button @click="onClick3($event)"></button>
  </div>
  <script src="node_modules/vue/dist/vue.js"></script>
  <script>
    new Vue({
      el: '#app',
      methods: {
        onClick (e) {
          console.log(e) // 事件对象
        },

        onClick2 (num) {
          console.log(num) // 123
        },

        onClick2 (num, e) {
          console.log(num) // 123
          console.log(e) // 事件对象
        }
      }
    })
  </script>
```



#### template   vue中的template

-  template 是 Vue 中特殊提供的一个元素，一般用于包裹多个同级节点做统一逻辑处理，不在渲染结果中
- 

### 在 template 上使用 v-for

当需要遍历多个元素而又不想增加额外的元素节点的时候，可以结合 Vue 中提供的 `template` 遍历渲染：

```html
<ul>
  <template v-for="item in items">
    <li>{{ item.msg }}</li>
    <li class="divider" role="presentation"></li>
  </template>
</ul>
```

### v-if 和 v-show 区别

- v-if 条件渲染，如果条件为  false，则不渲染元素
  - true 渲染 DOM
  - false 不渲染 DOM
- v-show 条件显示，无论条件的真假始终都渲染元素
  - true 渲染 DOM
  - false 渲染 DOM，不显示（display: none）
  - 不能和 v-else、v-else-if 结合使用

> 一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。

### v-if 和 template

当你想要控制多个同级元素的渲染的时候而又不想增加额外的节点，可以结合 template，最终渲染结果中不会包含 template 元素：

```html
<template v-if="seen">
  <p>hello1</p>
  <p>hello2</p>
</template>
```



**注意：在 template 上使用 v-show 无效。**

##### 指令     指令 (Directives) 是带有 `v-` 前缀的特殊特性（属性）。

1. `v-once` 只渲染元素一次   vue中修改了变量数据以后 v-once 所在的元素也不会再重新渲染

   1. ```js
       <p v-once>{{mag}}</p>    页面中mag 只会渲染一次  
      ```

2. `v-cloak` 优化用户体验，**避免闪烁现象**

   - ```js
      <span v-cloak>{{student[0].name}}</span> 
             配合  [v-cloak] {
                     display: none;
                 }       一起使用
       
     ```

3. `v-pre` 所在元素不会被编译处理，可以理解为忽略

   1. ```js
       <p v-pre>{{mag}}</p>    页面中不会解析{{mag}}
      ```

4. `v-model` 获取表单元素中的值，支持修饰符
   - .lazy 取代 `input` 监听 `change` 事件
   - .number 字符串转为有效的数字
   - .trim 首尾空格过滤

5. `v-model` 在内部为不同的输入元素使用不同的属性并抛出不同的事件：
   - text 和 textarea 元素使用 `value` 属性和 `input` 事件；
   - checkbox 和 radio 使用 `checked` 属性和 `change` 事件；
   - select 字段将 `value` 作为 prop 并将 `change` 作为事件。





##### 修饰符    v-model.修饰符

1. `.lazy`      改input事件为change事件 （在input中）
2. `.number`  转数字
3. `.trim`    去除值两边的空格
4. `.stop`     阻止冒泡



###### 计算属性

- 实例化 Vue 时通过 `data` 初始的数据都是确定的，然后开发中经常遇到不确定的数据

- computed              通过**计算属性**非常方便的解决了"不确定数据"的获取，而且计算属性也是响应式的。

- **如果使用计算属性时，数据是会有缓存的，某种程度上是有利于提升性能。**

###### 侦听器

- 在 Vue 中数据的变化是响应式的，这一切都由 Vue 内部自动处理，给开发者带来了极大的方便，然而某些复杂的场景（数据校验、异步请求等）**需要开发者能够监听到数据的变化并执行特定的逻辑。
- 侦听器为开发者提供了更为精细的控制数据变化的方案

## 插值绑定

### 文本

 数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值： 

```html
<p>{{ message }}</p>
<span>{{ message }}</span>
<strong>{{ message }}</strong>
```

### JavaScript 表达式

`{{}}` 中可以有一些简单的 JavaScript 逻辑运算：

```html
<p>{{ number + 1 }}</p>
<p>{{ number + 1 > 10 ? 'number大于10' : 'number小于10' }}</p>
<p>{{ arr }}</p>
<p>{{ message.split('').reverse().join('') }}</p>
```

### 遍历对象  

遍历值：

```html
<p v-for="value in user">{{ value }}</p>
```

带有值+属性名：

```html
<p v-for="(value, name) in user">{{ name }} -- {{ value }}</p>
```

遍历值+属性名+索引：

```html
<p v-for="(value, name, index) in user">{{ index }} -- {{ name }} -- {{ value }}</p>
```

![image-20191104115443216](D:\00笔记—来于小雨\00笔记\assets\image-20191104115443216.png)



### 对象的更新

已知实例中 data 的数据：

```js
const app = new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue.js!',
    user: {
      // 初始化了的都可以正常的更新
      name: 'Jack',
      age: 18,
      // 没有初始化的不能直接修改数据更新视图，例如 app.user.gender = '男'
    }
  }
})

```



常规方式修改对象数据更新视图：

```js
app.user.name = 'Rose' // 可以更新

app.user.gender = '女' // 不会更新，因为 gender 没有初始化

app.user = { name: 'Rose', age: 16, gender: '女' } // 可以更新
```

如果想要动态添加一个可以更新视图的对象成员数据：

```js
// 参数1：实例的数据对象
// 参数2：属性名（注意：属性名是一个字符串）
// 参数3：属性值
Vue.set(vm.userProfile, 'age', 27)
```

> 一个建议就是最好都把数据提前初始化好。
>
> 

#### 遍历数组  <li v-for="value in arr">

### 数组的更新

这些常见的数组操作方法都会正常的进行视图更新：

```js
push()
pop()
shift()
unshift()
splice()
sort()
reverse()
```

或者直接对数组进行重新赋值：

```js
实例.数组 = 新的数组
```

注意，以下两种情况都不会更新视图：

- 当你利用索引直接设置一个数组项时，例如：`vm.items[indexOfItem] = newValue`
- 当你修改数组的长度时，例如：`vm.items.length = newLength`
  - 了解即可

对于问题1，我们可以使用 Vue 中提供的 `Vue.set` 方法来解决。

```js
// Vue.set
// 参数1： 实例的数组
// 参数2：索引
// 参数3：你要修改的那个数据新值
Vue.set(vm.items, indexOfItem, newValue)
```

### computed

需要根据一段逻辑产生一个数据值的业务建议选择计算属性。

## watch 侦听器 监听器

- 是一种功能 

  ![](D:\00笔记—来于小雨\00笔记\assets\侦听器.png)

  ```js
   watch: {
          // 对 data 中的 msg 进行侦听（监听）
          msg: function (newValue, oldValue) {
            // console.log('msg的数据正在发生改变...');
            // console.log(newValue);
  
            // 不要在侦听器对原始数据进行修改，否则会陷入死循环
            this.msg1 = newValue.split('').reverse().join('');
          },
  
          // 对年龄数据变化进行监听
          age: function (newValue, oldValue) {
            // 数据校验，只允许输入文字
            if(newValue != '' && !Number(newValue)) {
              this.age = oldValue;
            }
          },
  
          // 对 data 中的 text 进行侦听（监听）
          text: function () {}
        }
  ```

  

# 				JSON Server

- JSON Server 是一个提供测试环境接口的工具，它可以帮我们快速生成一套接口服务，专门用于学习测试。
- 它是免费开源的命令行工具

# 			axios

- [axios](https://github.com/axios/axios) 是一个基于 Promise 的第三方 HTTP 客户端请求库，可以用于浏览器或者 Node.js。
  axios 本身和 Vue 没有一毛钱关系，只是简单纯粹的封装了 HTTP 请求功能。可以运行在任何支持 JavaScript 环境的平台。



## 基本使用

### 安装

```shell
npm install axios
```

### 执行一个 `GET` 请求

```javascript
axios({ // 配置请求相关数据信息
      method: 'GET', // 请求方法
      url: 'http://localhost:3000/users', // 请求路径
      // params: {}, // Query 参数
      // data: {} // Body 参数
    }).then(function (res) {
      // res 是响应对象
      // 接口返回的数据再 res.data 中
      //    config: {url: "http://localhost:3000/users", method: "get", headers: {…}, transformRequest: Array(1), transformResponse: Array(1), …}
      //      本次请求配置信息对象，很少使用
      //    data: [{…}]
      //      真正的响应结果数据
      //    headers: {cache-control: "no-cache", content-length: "84", content-type: "application/json; charset=utf-8", expires: "-1", pragma: "no-cache"}
      //      响应头数据，很少使用
      //    request: XMLHttpRequest {readyState: 4, timeout: 0, withCredentials: false, upload: XMLHttpRequestUpload, onreadystatechange: ƒ, …}
      //      请求对象，几乎不适用
      //    status: 200
      //      响应状态码
      //    statusText: "OK"
      //      响应状态短语
      console.log(res.data)
    })
```

### 带有 Query 参数的 GET 请求

```js
const user = {
  name: '张三',
  age: 18
}

axios({
  method: 'GET',
  // url: 'http://localhost:3000/users?name=' + name + '&age=' + age,
  // url: `http://localhost:3000/users?name=${name}&age=${age}`,
  url: 'http://localhost:3000/users',
  // 配置 Query 查询参数
  // axios 在内部把 params 对象转换为 key=value&key=value 的数据格式
  // 然后放到 url 后面，把请求发出去
  params: {
    // name: user.name,
    age: user.age
  }
}).then(res => {
  console.log(res)
})
```



### 执行一个 `POST` 请求

```javascript
axios({
  method: 'POST',
  url: 'http://localhost:3000/users',
  data: { // POST 请求体放到 data 中
    name: '张三风',
    age: 50,
    gender: '男'
  }
}).then(res => {
  if (res.status === 201) {
    console.log('添加成功')
  }
})
```

### 执行一个 `DELETE` 请求

```js
axios({
  method: 'DELETE',
  url: 'http://localhost:3000/users/3'
}).then(res => {
  console.log(res)
})
```



### 执行一个 `PATCH` 请求

```js
axios({
  method: 'PATCH',
  url: 'http://localhost:3000/users/4',
  data: { // Body 请求体
    name: '张三丰'
  }
}).then(res => {
  console.log(res)
})
```



## axios API

### axios(config)

我们可以像使用 `$.ajax()` 一样来使用 `axios`。

```javascript
// Send a POST request
axios({
  method: 'post',
  url: '/user/12345',
  data: {
    firstName: 'Fred',
    lastName: 'Flintstone'
  }
})
```

```javascript
// GET request for remote image
axios({
  method: 'get',
  url: 'http://bit.ly/2mTM3nY',
  responseType: 'stream'
}).then(function(response) {
  response.data.pipe(fs.createWriteStream('ada_lovelace.jpg'))
})
```

### 请求方法别名(了解即可)

为了方便，axios 为所有的请求方法都提供了别名支持。

- axios.request(config)
- axios.get(url[, config])
- axios.delete(url[, config])
- axios.head(url[, config])
- axios.options(url[, config])
- axios.post(url[, data[, config]])
- axios.put(url[, data[, config]])
- axios.patch(url[, data[, config]])

> 注意：当使用了这些别名方法时，`url`, `method` 和 `data` 属性不需要声明在配置对象中。



## 响应体结构

请求的响应包含以下信息。

```json
{
  // `data` is the response that was provided by the server
  "data": {},

  // `status` is the HTTP status code from the server response
  "status": 200,

  // `statusText` is the HTTP status message from the server response
  "statusText": "OK",

  // `headers` the headers that the server responded with
  // All header names are lower cased
  "headers": {},

  // `config` is the config that was provided to `axios` for the request
  "config": {},

  // `request` is the request that generated this response
  // It is the last ClientRequest instance in node.js (in redirects)
  // and an XMLHttpRequest instance the browser
  "request": {}
}
```

当使用 `then` 方法时，将收到如下结果

```js
axios.get('/user/12345').then(function(response) {
  console.log(response.data)
  console.log(response.status)
  console.log(response.statusText)
  console.log(response.headers)
  console.log(response.config)
})
```

## 配置

### 配置 baseUrl

```js
// 配置请求的基础路径
axios.defaults.baseURL = 'https://api.example.com'
```



## 处理错误

```js
axios({
  method: 'PATCH',
  url: '/users/2',
  data: {
    name: 'abc'
  }
}).then((res) => { // 成功执行 then
  // 在 axios 中，默认只有 >=200 和 <400 的状态码都认为是成功的
  // axios 在请求失败以后就不执行 then 里面的代码了
  console.log('请求结果 => ', res)
}).catch(err => { // 失败执行 catch
  console.log('请求失败了', err)
  window.alert('更新失败，请稍后重试！')
})
```



###   组件

- 组件特点: 组件是一个**`特殊的 Vue实例     独立的作用域

- ```html
  <div id="app">
          <!-- 使用组件 直接写组件的名称标签即可   -->
          <!-- 写了一个标签 相当于 一个组件实例 -->
          <eight-eight> </eight-eight>
          <eight-eight> </eight-eight>
      </div>
      <script src="./vue.js"></script>
      <script>
          //  全局组件 注册 应该放在 Vue实例化之前
          // Vue.component(组件名称,组件对象)
          // abc 单词 或者 abc-d 双词 (建议全小写)
          Vue.component("eight-eight", {
              //   组件对象
              template: `<div>
                       <p>hello 大家好</p>
                       <p>{{ name }}</p>
                       <input type='text' v-model="name" />
                     </div>
           `,
              data: function() {
                  return {
                      name: "字节跳动"
                  };
              },
              methods: {},
              computed: {},
              watch: {},
              created() {},
              mounted() {}
          });
          var vm = new Vue({
              el: "#app",
              data: {},
              methods: {}
          });
      </script>
  ```

- 

- 和Vue实例相似之处:   data/methods/computed/watch  等一应俱全   Vue实例有的 组件基本都有

  组件没有el ,但是有template => 组件页面结构 

  **注意** 值得注意的是  data和Vue实例的区别为 组件中data为一个函数   没有el选项 

  组件的data是一个带**`返回值的函数`** => 因为组件的数据是独立的,data => 返回一个新数据 

  template 代表其**`页面结构`** (有且只要一个根元素)

  每个组件都是**`独立`**的 运行作用域  数据 逻辑没有任何关联

#### 局部组件: 

局部组件只能在当前实例中使用

#### 全局组件

全局和局部: 注册方式不同 应用范围不同

#### 组件嵌套   

- 就是在**`组件中`**使用**`其他组件`**

  

```html
<div id="app">
        <!-- 定义属性 -->
        <city :citylist="list"></city>
    </div>
    <script src="./vue.js"></script>
    <script>
        //  全局组件 注册 应该放在 Vue实例化之前
        // Vue.component(组件名称,组件对象)
        // abc 单词 或者 abc-d 双词 (建议全小写)
        Vue.component("city", {
             // 页面结构 => 有且只有一个根节点
            template: `<div>
        <p>我是城市</p>
        <li v-for="item in citylist" v-text="item"></li>
        </div>`,
            props: ["citylist"]
        });
        var vm = new Vue({
            el: "#app",
            data: {
                list: ["北京", "上海", "天津", "重庆"]
            },
            methods: {}
        });
    </script>
```

#### 单页应用-SPA的特点

> **`目标`**  掌握SPA的特点 single  page  application
>
> - 传统模式 每个页面及其内容都需要从服务器一次次请求  如果网络差, 体验则会感觉很慢
> - spa模式, **`第一次`**加载 会将所有的资源都请求到页面 **`模块之间切换`**不会再请求服务器
>
> SPA优点

1. 用户体验好,因为前段操作几乎感受不到网络的延迟
2. 完全组件化开发 ,由于只有一个页面,所以原来属于一个个页面的工作被归类为一个个**`组件`**.

> 缺点

1. **`首屏`**加载慢->**`按需加载`** 不刷新页面 只请求js模块
2. 不利于SEO->**`服务端渲染`**(node->自己写路由->express-art-template+res.render())
3. **`开发难度高`**(框架) 相对于传统模式,有一些学习成本和应用成本

> vue适合开发SPA->什么是SPA+SPA特点
>
> SPA不利于SEO->搜索引擎排名靠前->搜素引擎机制->搜索引擎不能去找到局部刷新的网站内容

## 基础-单页应用-SPA-实现原理

> **`目标`** 掌握前段SPA的实现原理
>
> - SPA要实现 能够在前端自由切换模块 
> - SPA要能记忆当前切换的模块,并且刷新页面模块依然还在当前视图
> - SPA要实现在前端切换模块时,不能引起页面刷新,否则页面内容会被重置
>
> **`结论`**
>
> - 可以通过页面地址的锚链接来实现spa
> - hash(锚链接)位于链接地址 **`#`**之后
> - hash值的改变**`不会触发`**页面刷新
> - hash值是url地址的一部分,会存储在页面地址上 我们可以获取到
> - 可以通过**`事件监听`**hash值得改变
> - 拿到了hash值,就可以根据不同的hash值进行不同的**`模块切换`**

## 路由-vue-router-文档

> **`目标`**  了解vue-router是什么
>
> - Vue-Router 是 [Vue.js](http://cn.vuejs.org/) 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建**单页面**应用变得易如反掌   它是一个插件
> - Vuejs中不包含vue-router
> - 实现根据不同的请求地址 而**`显示不同的组件`**
> - 如果要使用 vue开发项目,前端路由功能**`必须使用`**vue-router来实现
>
> #### -路由-vue-router-体验及使用步骤
>
>  <!-- 1 引入vue-router -->
>
>  <!-- 2. 定义导航 -->
>
>  <!-- 3. 定义容器 -->
>
>  <!-- 4 实例化一个VueRouter -->
>
>  <!-- 5 配置路由表  一个地址 => 一个组件(模块) -->
>
>  <!-- 6 挂载路由 -->

如何在页面中使用vue-router

1. 导入vue和vue-router
2. 设置HTML中的内容

```html
<!-- router-link 最终会被渲染成a标签，to指定路由的跳转地址 -->
<router-link to="/users">用户管理</router-link>

<!-- 路由匹配到的组件将渲染在这里 -->
<router-view></router-view>
```

3. 创建组件

```js
// 创建组件
// 组件也可以放到单独的js文件中
var Home = {
template: '<div>这是Home内容</div>'
};
var Users = {
template: '<div>这是用户管理内容</div>'
};
```

4. 实例化路由对象,配置路由规则

```js
// 配置路由规则
var router = new VueRouter({
routes: [
{ name: 'home', path: '/', component: Home },
{ name: 'users', path: '/users', component: Users }
]
});
```

5. vue实例挂载router实例

```js
var vm = new Vue({
el: '#app',
router
});
```

## 路由-vue-router-to属性赋值

> **`目标`**掌握 vue-router中的to的多种赋值方式
>
> - to 有多种赋值方式  

```html
      <!-- 常规跳转 -->
      <!-- <router-link to="/sport">体育</router-link> -->
      <!-- 变量 -->
      <!-- <router-link :to="path">体育</router-link> -->
      <!-- 根据对象name跳转 -->
      <!-- <router-link :to="{name:'abcdefg'}">体育</router-link> -->
      <!-- 根据对象path跳转 -->
      <!-- <router-link :to="{path:'/sport'}">体育</router-link> -->
      <!-- 带参数的跳转 -->
      <router-link :to="{name:'abcdefg',params:{a:1}}">体育</router-link>
```

#### 路由-vue-router-动态路由   this.$route.params

- Vue-router的动态路由如何使用

  - 点击**`列表页`** 跳转到**`详情页`**时,跳转的链接需要携带参数,会导致**`path`**不同
  - 当path不同却需要对应同一个组件时,需要用到动态路由这一概念
  - 动态路由传参 =>  列表 =>详情 => 动态路由id传过去

- 此时可以通过路由传参来实现，具体步骤如下：

  1. 路由规则中增加参数，在path最后增加 **:id**

  ```js
  { name: 'users', path: '/users/:id', component: Users },
  ```

  2. 通过 <router-link> 传参，在路径上传入具体的值

  ```html
  <router-link to="/users/120">用户管理</router-link>
  ```

  3. 在组件内部可以使用，**this.$route** 获取当前路由对象

  ```js
  var Users = {
     template: '<div>这是用户管理内容 {{ $route.params.id }}</div>',
     mounted() {
         console.log(this.$route.params.id);
     }
  };
  ```

  **`任务`**

#### **路由-vue-router-编程式导航`**

- 跳转不同的组件 不仅仅可以用router-link 还可以采用**`代码行为`**
- (Vue实例/组件实例)**`this.$router`** 可以拿到当前路由对象的实例
- 路由对象的实例方法 有 push  replace, go()  
- push 方法 相当于往历史记录里推了一条记录 如果点击返回 会回到上一次的地址
- replace方法 想相当于替换了当前的记录  历史记录并没有多 但是地址会变
- go(数字) 代表希望是前进还是回退,当数字大于0 时 就是前进 n(数字)次,小于0时,就是后退n(数字)次
- 可以通过vue实例 获取当前的路由实例 $router 

```js
goPage() {
   // 跳转到新闻页面
   this.$router.push({
          path: "/news"
        });
      }
```



## 路由-vue-router-重定向

> **`目标`**掌握路由-vue-router-重定向
>
> 场景: 当希望某个页面被强制中转时  可采用redirect 进行路由重定向设置
>
> ```json
> {
>   path: "/sport",
>   redirect: "/news", // 强制跳转新闻页
>   component: {
>     template: `<div>体育</div>`
>   }
> },
> ```

#### 路由-vue-router-routerlink-tag-激活样式

​    <a href="#/news" class="router-link-exact-active router-link-active">新闻</a>

#### router-link

### <router-link tag="li" to="/heroes">

router-link 组件**`默认生成`**的a标签 =>  可以通过一个属性 来改变其最终生成的标签 => tag (标签)

router-link **`默认`**激活样式 是  router-link-active   => 可以通过属性将默认的激活样式换掉  linkActiveClass

  **统一激活样式  **    linkActiveClass: "active", // active为bootstrap中的 一个class样式





## 知识点 黑马头条





















